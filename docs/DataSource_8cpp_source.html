<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CUBRID Engine: src/oledb/DataSource.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CUBRID Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('DataSource_8cpp_source.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">DataSource.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<a href="DataSource_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">/*</span></div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="comment"> * Copyright (C) 2008 Search Solution Corporation. All rights reserved by Search Solution. </span></div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment"> * Redistribution and use in source and binary forms, with or without modification, </span></div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment"> * are permitted provided that the following conditions are met: </span></div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="comment"> * - Redistributions of source code must retain the above copyright notice, </span></div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="comment"> *   this list of conditions and the following disclaimer. </span></div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="comment"> * - Redistributions in binary form must reproduce the above copyright notice, </span></div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="comment"> *   this list of conditions and the following disclaimer in the documentation </span></div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="comment"> *   and/or other materials provided with the distribution. </span></div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="comment"> * - Neither the name of the &lt;ORGANIZATION&gt; nor the names of its contributors </span></div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="comment"> *   may be used to endorse or promote products derived from this software without </span></div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="comment"> *   specific prior written permission. </span></div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND </span></div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="comment"> * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED </span></div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="comment"> * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. </span></div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="comment"> * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, </span></div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="comment"> * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, </span></div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="comment"> * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, </span></div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="comment"> * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, </span></div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="comment"> * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) </span></div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="comment"> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY </span></div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="comment"> * OF SUCH DAMAGE. </span></div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="oledb_2stdafx_8h.html">stdafx.h</a>&quot;</span></div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="DataSource_8h.html">DataSource.h</a>&quot;</span></div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="Error_8h.html">Error.h</a>&quot;</span></div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="ProviderInfo_8h.html">ProviderInfo.h</a>&quot;</span></div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;<span class="comment">//const OLEDBDECLSPEC GUID DBPROPSET_UNIPROVIDER_DBINIT = {0x7f555b1d,0xc6d2,0x40ce,{0x9a,0xb4,0x49,0x62,0x78,0x1e,0xb6,0x6c}};</span></div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;<span class="comment">//extern &quot;C&quot; {</span></div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;<span class="comment">//char cci_client_name[8] = &quot;ODBC&quot;;</span></div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;<span class="comment">//}</span></div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;</div><div class="line"><a name="l00042"></a><span class="lineno"><a class="line" href="classCCUBRIDDataSource.html#a5ed51ee59404677ed8ee6848124878af">   42</a></span>&#160;<a class="code" href="classCCUBRIDDataSource.html">CCUBRIDDataSource</a> *<a class="code" href="classCCUBRIDDataSource.html#a5ed51ee59404677ed8ee6848124878af">CCUBRIDDataSource::GetDataSourcePtr</a>(IObjectWithSite *pSite)</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;{</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    CComPtr&lt;IDBCreateSession&gt; spCom;</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    HRESULT hr = pSite-&gt;GetSite(__uuidof(IDBCreateSession), (<span class="keywordtype">void</span> **)&amp;spCom);</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    <span class="comment">// 제대로 프로그래밍 됐을때, 실패하는 경우가 있을까?</span></div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    ATLASSERT(SUCCEEDED(hr));</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    <span class="comment">// 굳이 오버헤드를 감수해가며 dynamic_cast를 쓸 필요는 없을 듯   return static_cast&lt;CCUBRIDDataSource *&gt;((IDBCreateSession *)spCom);
}

STDMETHODIMP CCUBRIDDataSource::Initialize(void)
{
    ATLTRACE2(atlTraceDBProvider, 2, &quot;CCUBRIDDataSource::Initialize\n&quot;);

    // 현재 오류객체를 제거한다.
    ClearError();

    // 연결정보들(ID, 암호등)이 올바른지 확인한다.
    char dbmsver[16];
    {
        int hConn = 0;
        //T_CCI_ERROR error;

        HRESULT hr = Util::Connect(this, &amp;hConn);
        if(FAILED(hr)) return hr;

        char buf[16];
        T_CCI_ERROR error;
        int rc = cci_get_db_version(hConn, buf, sizeof(buf));
        if(rc&lt;0)
        {
            ATLASSERT(rc!=CCI_ER_CON_HANDLE);
            // rc==CCI_ER_CONNECT -&gt; 주소나 포트가 틀림
            // rc==CAS_ER_DBMS -&gt; DB 이름이나 ID, 암호가 틀림

            ATLTRACE2(atlTraceDBProvider, 0, &quot;CCUBRIDDataSource::Initialize : cci_get_db_version failed with rc=%d\n&quot;, rc);
            Util::Disconnect(&amp;hConn);

            CComVariant var;
            var = DBPROPVAL_CS_COMMUNICATIONFAILURE;
            SetPropValue(&amp;DBPROPSET_DATASOURCEINFO, DBPROP_CONNECTIONSTATUS, &amp;var);

            return RaiseError(DB_SEC_E_AUTH_FAILED, 0, __uuidof(IDBInitialize), (LPWSTR)0, L&quot;42000&quot;);
        }

        //최대 스트링 갯수를 나타내는 데이터베이스 파라메터를 가져온다.
        rc = cci_get_db_parameter(hConn, CCI_PARAM_MAX_STRING_LENGTH, &amp;PARAM_MAX_STRING_LENGTH, &amp;error);
        if (rc &lt; 0)
        {
            Util::Disconnect(&amp;hConn);

            CComVariant var;
            var = DBPROPVAL_CS_COMMUNICATIONFAILURE;
            SetPropValue(&amp;DBPROPSET_DATASOURCEINFO, DBPROP_CONNECTIONSTATUS, &amp;var);

            return RaiseError(E_FAIL, 0, __uuidof(IDBInitialize), error.err_msg);
        }

        Util::Disconnect(&amp;hConn);

        int a=0, b=0, c=0;
        sscanf(buf, &quot;%2d.%2d.%2d&quot;, &amp;a, &amp;b, &amp;c);
        sprintf(dbmsver, &quot;%02d.%02d.%04d&quot;, a, b, c);
    }

    // ATL의 초기화 루틴을 호출
    {
        HRESULT hr = IDBInitializeImpl&lt;CCUBRIDDataSource&gt;::Initialize();
        if(FAILED(hr)) return hr;
    }

    // set properties
    {
        CComVariant var;
        // 읽기 전용 속성이므로 IDBProperties::SetProperties를 이용할 수 없다.
        // 대신 내부적으로 IDBProperties에 이용된 CUtlProps::SetPropValue를 사용한다.
        // 외부적으론 변경할 수 없지만, 내부적으로 변경할 수 있도록
     // DBPROPFLAGS_CHANGE flag를 추가한다.
        var = dbmsver;
        SetPropValue(&amp;DBPROPSET_DATASOURCEINFO, DBPROP_DBMSVER, &amp;var);

        VariantClear(&amp;var);
        VariantInit(&amp;var);
        var = &quot;2.0.01.004&quot;;

        SetPropValue(&amp;DBPROPSET_DATASOURCEINFO, DBPROP_PROVIDERVER, &amp;var);

        GetPropValue(&amp;DBPROPSET_DBINIT, DBPROP_INIT_LOCATION, &amp;var);
        SetPropValue(&amp;DBPROPSET_DATASOURCEINFO, DBPROP_DATASOURCENAME, &amp;var);

        var = DBPROPVAL_CS_INITIALIZED;
        SetPropValue(&amp;DBPROPSET_DATASOURCEINFO, DBPROP_CONNECTIONSTATUS, &amp;var);
        
    }

    return S_OK;
}

STDMETHODIMP CCUBRIDDataSource::Uninitialize(void)
{
    ATLTRACE2(atlTraceDBProvider, 2, &quot;CCUBRIDDataSource::Uninitialize\n&quot;);

    CComVariant var;

    // 현재 오류객체를 제거한다.
    ClearError();

    // ATL의 루틴을 호출
    {
        HRESULT hr = IDBInitializeImpl&lt;CCUBRIDDataSource&gt;::Uninitialize();
        if(FAILED(hr)) return hr;
    }

    var = DBPROPVAL_CS_UNINITIALIZED;
    SetPropValue(&amp;DBPROPSET_DATASOURCEINFO, DBPROP_CONNECTIONSTATUS, &amp;var);

    return S_OK;
}

STDMETHODIMP CCUBRIDDataSource::CreateSession(IUnknown *pUnkOuter, REFIID riid, IUnknown **ppDBSession)
{
    if(ppDBSession==NULL) return E_INVALIDARG;
    *ppDBSession = NULL;

    // DBPROP_ACTIVESESSIONS 개수 이상의 session을 열 수 없다.
    {
        CComVariant var;
        HRESULT hr = GetPropValue(&amp;DBPROPSET_DATASOURCEINFO, DBPROP_ACTIVESESSIONS, &amp;var);
        if(FAILED(hr)) return hr;

        ATLASSERT(var.vt==VT_I4);
        int cActSessions = V_I4(&amp;var);

        if(cActSessions!=0 &amp;&amp; this-&gt;m_cSessionsOpen&gt;=cActSessions)
            return DB_E_OBJECTCREATIONLIMITREACHED;
    }

    // DBPROP_MULTIPLECONNECTIONS==FALSE면
  // 여러 개의 connection handle을 여는 것을 허용하지 않음
    /*
    {
        CComVariant var;
        HRESULT hr = GetPropValue(&amp;DBPROPSET_DATASOURCE, DBPROP_MULTIPLECONNECTIONS, &amp;var);
        if(FAILED(hr)) return hr;

        ATLASSERT(var.vt==VT_BOOL);
        bool bMulSessions = V_BOOL(&amp;var);

        if(!bMulSessions &amp;&amp; this-&gt;m_cSessionsOpen!=0)
            return DB_E_OBJECTOPEN;
    }
    */

    return IDBCreateSessionImpl&lt;CCUBRIDDataSource, CCUBRIDSession&gt;::CreateSession(pUnkOuter, riid, ppDBSession);
}

STDMETHODIMP CCUBRIDDataSource::GetLiteralInfo(ULONG cLiterals, const DBLITERAL rgLiterals[],
                              ULONG *pcLiteralInfo, DBLITERALINFO **prgLiteralInfo,
                              OLECHAR **ppCharBuffer)
{
    ATLTRACE(atlTraceDBProvider, 2, _T(&quot;CCUBRIDDataSource::GetLiteralInfo\n&quot;));
    ObjectLock lock(this);

    // 현재 오류객체를 제거한다.
    ClearError();

    // 초기화
    if( pcLiteralInfo )
        *pcLiteralInfo = 0;
    if( prgLiteralInfo )
        *prgLiteralInfo = NULL;
    if( ppCharBuffer )
        *ppCharBuffer = NULL;
        
    // 파라미터 체크
    if (!pcLiteralInfo || !prgLiteralInfo || !ppCharBuffer)
        return E_INVALIDARG;
    if( cLiterals != 0 &amp;&amp; rgLiterals == NULL )
        return E_INVALIDARG;

    // Data Source가 초기화 되었는지 확인
    if (!(m_dwStatus &amp; DSF_INITIALIZED))
        return E_UNEXPECTED;

    *ppCharBuffer = (WCHAR *)CoTaskMemAlloc(ProvInfo::size_wszAllStrings);
    if(*ppCharBuffer==NULL) return E_OUTOFMEMORY;
    memcpy(*ppCharBuffer, ProvInfo::wszAllStrings, ProvInfo::size_wszAllStrings);

    // 제공되는 모두 literal 정보 수
   const UINT numLiteralInfos = ProvInfo::size_LiteralInfos;

    // cLiterals가 0이면 모든 literal 정보 리턴
    *pcLiteralInfo = ( cLiterals==0 ? numLiteralInfos : cLiterals );

    // *pcLiteralInfo 만큼의 DBLITERALINFO 구조체 배열 할당
   *prgLiteralInfo = (DBLITERALINFO *)CoTaskMemAlloc(*pcLiteralInfo * sizeof(DBLITERALINFO));
    if (!*prgLiteralInfo)
    {
        ::CoTaskMemFree(*ppCharBuffer);
        *pcLiteralInfo = 0;
        *ppCharBuffer = 0;
        return E_OUTOFMEMORY;
    }

    ULONG ulSucceeded = 0;
    if(cLiterals)
    {   // 일부 literal 정보만 반환
        for(ULONG i=0;i&lt;*pcLiteralInfo;i++)
        {
            ULONG j;
            // 요청된 literal이 LiteralInfos에 있는지 찾아본다.
            for(j=0;j&lt;numLiteralInfos;j++)
            {
                if(ProvInfo::LiteralInfos[j].lt==rgLiterals[i])
                {
                    (*prgLiteralInfo)[i] = ProvInfo::LiteralInfos[j];
                    ulSucceeded++;
                    break;
                }
            }

            if(j==numLiteralInfos)
            {   // LiteralInfos에 없는 literal
                // fSupported도 자동으로 FALSE가 된다.
                ZeroMemory((*prgLiteralInfo)+i, sizeof(DBLITERALINFO));
                (*prgLiteralInfo)[i].lt = rgLiterals[i];
            }
        }
    }
    else
    {   // 모든 literal 정보를 반환
        for( ; ulSucceeded&lt;numLiteralInfos ; ulSucceeded++ )
            (*prgLiteralInfo)[ulSucceeded] = ProvInfo::LiteralInfos[ulSucceeded];
    }

    if(ulSucceeded==*pcLiteralInfo)
        return S_OK;
    else if(ulSucceeded!=0)
        return DB_S_ERRORSOCCURRED;
    else
    {
        // 스펙에 따라서 string buffer는 free하고, infos buffer는 놔둔다.
        ::CoTaskMemFree(*ppCharBuffer);
        *ppCharBuffer = NULL;
        return DB_E_ERRORSOCCURRED;
    }
}

STDMETHODIMP CCUBRIDDataSource::GetKeywords(LPOLESTR *ppwszKeywords)
{
    ATLTRACE(atlTraceDBProvider, 2, _T(&quot;CCUBRIDDataSource::GetKeywords\n&quot;));
    ObjectLock lock(this);
    
    // 현재 오류객체를 제거한다.
    ClearError();

    // check params
    if (ppwszKeywords == NULL)
        return E_INVALIDARG;
    *ppwszKeywords = NULL;
    
    // check if data source object is initialized
    if (!(m_dwStatus &amp; DSF_INITIALIZED))
        return E_UNEXPECTED;

    // 키워드 리스트를 comma를 seperate 문자로 하여 continuous한 배열로 선언
  OLECHAR Keywords[] = L&quot;ABORT,ACTIVE,ADD_MONTHS,AFTER,ALIAS,ASYNC,ATTACH,ATTRIBUTE,&quot;
                         L&quot;BEFORE,BOOLEAN,BREADTH,CALL,CHANGE,CLASS,CLASSES,CLUSTER,&quot;
                         L&quot;COMMITTED,COMPLETION,COST,CYCLE,DATA,DATA_TYPE___,DECAY_CONSTANT,&quot;
                         L&quot;DEFINED,DEPTH,DICTIONARY,DIFFERENCE,DIRECTORY,DRAND,EACH,&quot;
                         L&quot;ELSEIF,EQUALS,EVALUATE,EVENT,EXCLUDE,FILE,FUNCTION,GDB,GENERAL,&quot;
                         L&quot;GROUPBY_NUM,GROUPS,HOST,IDENTIFIED,IF,IGNORE,INACTIVE,INCREMENT,&quot;
                         L&quot;INDEX,INFINITE,INHERIT,INOUT,INSTANCES,INST_NUM,&quot;
                         L&quot;INTERSECTION,INTRINSIC,INVALIDATE,LAST_DAY,LDB,LEAVE,LESS,LIMIT,LIST,&quot;
                         L&quot;LOCK,LOOP,LPAD,LTRIM,MAXIMUM,MAXVALUE,MAX_ACTIVE,&quot;
                         L&quot;MEMBERS,METHOD,MINVALUE,MIN_ACTIVE,MODIFY,MOD,MONETARY,&quot;
                         L&quot;MONTHS_BETWEEN,MULTISET,MULTISET_OF,NA,NAME,&quot;
                         L&quot;NEW,NOCYCLE,NOMAXVALUE,NOMINVALUE,NONE,OBJECT,OBJECT_ID,OFF,OID,OLD,&quot;
                         L&quot;OPERATION,OPERATORS,OPTIMIZATION,ORDERBY_NUM,OTHERS,OUT,PARAMETERS,&quot;
                         L&quot;PASSWORD,PENDANT,PREORDER,PRINT,PRIORITY,PRIVATE,PROXY,PROTECTED,&quot;
                         L&quot;QUERY,RAND,RECURSIVE,REF,REFERENCING,REGISTER,REJECT,RENAME,REPEATABLE,&quot;
                         L&quot;REPLACE,RESIGNAL,RETURN,RETURNS,ROLE,ROUTINE,ROW,ROWNUM,&quot;
                         L&quot;RPAD,RTRIM,SAVEPOINT,SCOPE___,SEARCH,SENSITIVE,SEQUENCE,&quot;
                         L&quot;SEQUENCE_OF,SERIAL,SERIALIZABLE,SETEQ,SETNEQ,SET_OF,SHARED,SHORT,SIGNAL,&quot;
                         L&quot;SIMILAR,SQLEXCEPTION,SQLWARNING,STABILITY,START,STATEMENT,STATISTICS,STATUS,&quot;
                         L&quot;STDDEV,STRING,STRUCTURE,SUBCLASS,SUBSET,SUBSETEQ,SUPERCLASS,&quot;
                         L&quot;SUPERSET,SUPERSETEQ,SYS_DATE,SYS_TIME,SYS_TIMESTAMP,SYS_USER,&quot;
                         L&quot;TEST,THERE,TIMEOUT,TO_CHAR,TO_DATE,TO_NUMBER,TO_TIMETO_TIMESTAMP,&quot;
                         L&quot;TRACE,TRIGGERS,TYPE,UNDER,USE,UTIME,VARIABLE,VARIANCE,&quot;
                         L&quot;VCLASS,VIRTUAL,VISIBLE,WAIT,WHILE,WITHOUT&quot;;

    // 버퍼를 생성한다 
    *ppwszKeywords = (LPWSTR)CoTaskMemAlloc(sizeof(Keywords));
    if( *ppwszKeywords == NULL )
        return E_OUTOFMEMORY;

    // Copy keywords
    wcscpy( *ppwszKeywords, Keywords );
    
    return S_OK;
}
</span></div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><a class="code" href="classCCUBRIDDataSource.html">CCUBRIDDataSource</a> *<span class="keyword">&gt;</span>((IDBCreateSession *)spCom);</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;}</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;</div><div class="line"><a name="l00052"></a><span class="lineno"><a class="line" href="classCCUBRIDDataSource.html#ae559e4101dfc33ee20a818d851242fd7">   52</a></span>&#160;STDMETHODIMP <a class="code" href="classCCUBRIDDataSource.html#ae559e4101dfc33ee20a818d851242fd7">CCUBRIDDataSource::Initialize</a>(<span class="keywordtype">void</span>)</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;{</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    ATLTRACE2(atlTraceDBProvider, 2, <span class="stringliteral">&quot;CCUBRIDDataSource::Initialize\n&quot;</span>);</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    <span class="comment">// 현재 오류객체를 제거한다.</span></div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    <a class="code" href="Error_8cpp.html#a93f7a306ed9bf1f41de89f2afea7f55d">ClearError</a>();</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    <span class="comment">// 연결정보들(ID, 암호등)이 올바른지 확인한다.</span></div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    <span class="keywordtype">char</span> dbmsver[16];</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    {</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;        <span class="keywordtype">int</span> hConn = 0;</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;        <span class="comment">//T_CCI_ERROR error;</span></div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;        HRESULT hr = <a class="code" href="namespaceUtil.html#aba4c685b27429329ec3ebc36c1a55024">Util::Connect</a>(<span class="keyword">this</span>, &amp;hConn);</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;        <span class="keywordflow">if</span>(FAILED(hr)) <span class="keywordflow">return</span> hr;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;        <span class="keywordtype">char</span> buf[16];</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;        <a class="code" href="structT__CCI__ERROR.html">T_CCI_ERROR</a> <a class="code" href="run-tests_8php.html#aaa193b0c1c2b93841472b26e2e281751">error</a>;</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;        <span class="keywordtype">int</span> rc = <a class="code" href="cas__cci_8c.html#ad388b647a3df564cb7daaec00c10418d">cci_get_db_version</a>(hConn, buf, <span class="keyword">sizeof</span>(buf));</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;        <span class="keywordflow">if</span>(rc&lt;0)</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;        {</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;            ATLASSERT(rc!=<a class="code" href="cas__cci_8h.html#ad021d99d0eff7e3b483debe7ae0a67b0a62673d6fbc10807feb22ecf63cf2a014">CCI_ER_CON_HANDLE</a>);</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;            <span class="comment">// rc==CCI_ER_CONNECT -&gt; 주소나 포트가 틀림</span></div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;            <span class="comment">// rc==CAS_ER_DBMS -&gt; DB 이름이나 ID, 암호가 틀림</span></div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;            ATLTRACE2(atlTraceDBProvider, 0, <span class="stringliteral">&quot;CCUBRIDDataSource::Initialize : cci_get_db_version failed with rc=%d\n&quot;</span>, rc);</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;            <a class="code" href="namespaceUtil.html#a4f24c33d43a0f5439b654b1239599177">Util::Disconnect</a>(&amp;hConn);</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;            CComVariant var;</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;            var = DBPROPVAL_CS_COMMUNICATIONFAILURE;</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;            <a class="code" href="classCUtlProps.html#a65763fbb6841a5b66fb0cd96b9a01fc9">SetPropValue</a>(&amp;DBPROPSET_DATASOURCEINFO, DBPROP_CONNECTIONSTATUS, &amp;var);</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="Error_8cpp.html#afda786ad5a25ec751d57b3b84d89dfec">RaiseError</a>(DB_SEC_E_AUTH_FAILED, 0, __uuidof(IDBInitialize), (LPWSTR)0, L<span class="stringliteral">&quot;42000&quot;</span>);</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;        }</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;        <span class="comment">//최대 스트링 갯수를 나타내는 데이터베이스 파라메터를 가져온다.</span></div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;        rc = <a class="code" href="cas__cci_8c.html#aa4fe754e67b8fb5f03d83d5b208d6be4">cci_get_db_parameter</a>(hConn, <a class="code" href="cas__cci_8h.html#a817a20323faf621d14b51bbaa4e4fcc8a7ef450f2374ea3427216e8d3ae4a333c">CCI_PARAM_MAX_STRING_LENGTH</a>, &amp;<a class="code" href="classCCUBRIDDataSource.html#aa5c311fe1d5a832eecab64cecf9e7b4d">PARAM_MAX_STRING_LENGTH</a>, &amp;<a class="code" href="run-tests_8php.html#aaa193b0c1c2b93841472b26e2e281751">error</a>);</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;        <span class="keywordflow">if</span> (rc &lt; 0)</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;        {</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;            <a class="code" href="namespaceUtil.html#a4f24c33d43a0f5439b654b1239599177">Util::Disconnect</a>(&amp;hConn);</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;            CComVariant var;</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;            var = DBPROPVAL_CS_COMMUNICATIONFAILURE;</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;            <a class="code" href="classCUtlProps.html#a65763fbb6841a5b66fb0cd96b9a01fc9">SetPropValue</a>(&amp;DBPROPSET_DATASOURCEINFO, DBPROP_CONNECTIONSTATUS, &amp;var);</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="Error_8cpp.html#afda786ad5a25ec751d57b3b84d89dfec">RaiseError</a>(E_FAIL, 0, __uuidof(IDBInitialize), <a class="code" href="run-tests_8php.html#aaa193b0c1c2b93841472b26e2e281751">error</a>.err_msg);</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;        }</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;        <a class="code" href="namespaceUtil.html#a4f24c33d43a0f5439b654b1239599177">Util::Disconnect</a>(&amp;hConn);</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;        <span class="keywordtype">int</span> <a class="code" href="mprec_8c.html#a4124bc0a9335c27f086f24ba207a4912">a</a>=0, <a class="code" href="mprec_8c.html#a91b64995742fd30063314f12340b4b5a">b</a>=0, <a class="code" href="mprec_8c.html#a66b97d6dee15f33d7b6731ccf48092cf">c</a>=0;</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;        sscanf(buf, <span class="stringliteral">&quot;%2d.%2d.%2d&quot;</span>, &amp;<a class="code" href="mprec_8c.html#a4124bc0a9335c27f086f24ba207a4912">a</a>, &amp;<a class="code" href="mprec_8c.html#a91b64995742fd30063314f12340b4b5a">b</a>, &amp;<a class="code" href="mprec_8c.html#a66b97d6dee15f33d7b6731ccf48092cf">c</a>);</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;        sprintf(dbmsver, <span class="stringliteral">&quot;%02d.%02d.%04d&quot;</span>, <a class="code" href="mprec_8c.html#a4124bc0a9335c27f086f24ba207a4912">a</a>, <a class="code" href="mprec_8c.html#a91b64995742fd30063314f12340b4b5a">b</a>, <a class="code" href="mprec_8c.html#a66b97d6dee15f33d7b6731ccf48092cf">c</a>);</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    }</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;    <span class="comment">// ATL의 초기화 루틴을 호출</span></div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;    {</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;        HRESULT hr = <a class="code" href="classIDBInitializeImpl.html#a1a8b8105f2c6e9215cef57f2b934aa52">IDBInitializeImpl&lt;CCUBRIDDataSource&gt;::Initialize</a>();</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;        <span class="keywordflow">if</span>(FAILED(hr)) <span class="keywordflow">return</span> hr;</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;    }</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;    <span class="comment">// set properties</span></div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;    {</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;        CComVariant var;</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;        <span class="comment">// 읽기 전용 속성이므로 IDBProperties::SetProperties를 이용할 수 없다.</span></div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;        <span class="comment">// 대신 내부적으로 IDBProperties에 이용된 CUtlProps::SetPropValue를 사용한다.</span></div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;        <span class="comment">// 외부적으론 변경할 수 없지만, 내부적으로 변경할 수 있도록      // DBPROPFLAGS_CHANGE flag를 추가한다.
        var = dbmsver;
        SetPropValue(&amp;DBPROPSET_DATASOURCEINFO, DBPROP_DBMSVER, &amp;var);

        VariantClear(&amp;var);
        VariantInit(&amp;var);
        var = &quot;2.0.01.004&quot;;

        SetPropValue(&amp;DBPROPSET_DATASOURCEINFO, DBPROP_PROVIDERVER, &amp;var);

        GetPropValue(&amp;DBPROPSET_DBINIT, DBPROP_INIT_LOCATION, &amp;var);
        SetPropValue(&amp;DBPROPSET_DATASOURCEINFO, DBPROP_DATASOURCENAME, &amp;var);

        var = DBPROPVAL_CS_INITIALIZED;
        SetPropValue(&amp;DBPROPSET_DATASOURCEINFO, DBPROP_CONNECTIONSTATUS, &amp;var);
        
    }

    return S_OK;
}

STDMETHODIMP CCUBRIDDataSource::Uninitialize(void)
{
    ATLTRACE2(atlTraceDBProvider, 2, &quot;CCUBRIDDataSource::Uninitialize\n&quot;);

    CComVariant var;

    // 현재 오류객체를 제거한다.
    ClearError();

    // ATL의 루틴을 호출
    {
        HRESULT hr = IDBInitializeImpl&lt;CCUBRIDDataSource&gt;::Uninitialize();
        if(FAILED(hr)) return hr;
    }

    var = DBPROPVAL_CS_UNINITIALIZED;
    SetPropValue(&amp;DBPROPSET_DATASOURCEINFO, DBPROP_CONNECTIONSTATUS, &amp;var);

    return S_OK;
}

STDMETHODIMP CCUBRIDDataSource::CreateSession(IUnknown *pUnkOuter, REFIID riid, IUnknown **ppDBSession)
{
    if(ppDBSession==NULL) return E_INVALIDARG;
    *ppDBSession = NULL;

    // DBPROP_ACTIVESESSIONS 개수 이상의 session을 열 수 없다.
    {
        CComVariant var;
        HRESULT hr = GetPropValue(&amp;DBPROPSET_DATASOURCEINFO, DBPROP_ACTIVESESSIONS, &amp;var);
        if(FAILED(hr)) return hr;

        ATLASSERT(var.vt==VT_I4);
        int cActSessions = V_I4(&amp;var);

        if(cActSessions!=0 &amp;&amp; this-&gt;m_cSessionsOpen&gt;=cActSessions)
            return DB_E_OBJECTCREATIONLIMITREACHED;
    }

    // DBPROP_MULTIPLECONNECTIONS==FALSE면
  // 여러 개의 connection handle을 여는 것을 허용하지 않음
    /*
    {
        CComVariant var;
        HRESULT hr = GetPropValue(&amp;DBPROPSET_DATASOURCE, DBPROP_MULTIPLECONNECTIONS, &amp;var);
        if(FAILED(hr)) return hr;

        ATLASSERT(var.vt==VT_BOOL);
        bool bMulSessions = V_BOOL(&amp;var);

        if(!bMulSessions &amp;&amp; this-&gt;m_cSessionsOpen!=0)
            return DB_E_OBJECTOPEN;
    }
    */

    return IDBCreateSessionImpl&lt;CCUBRIDDataSource, CCUBRIDSession&gt;::CreateSession(pUnkOuter, riid, ppDBSession);
}

STDMETHODIMP CCUBRIDDataSource::GetLiteralInfo(ULONG cLiterals, const DBLITERAL rgLiterals[],
                              ULONG *pcLiteralInfo, DBLITERALINFO **prgLiteralInfo,
                              OLECHAR **ppCharBuffer)
{
    ATLTRACE(atlTraceDBProvider, 2, _T(&quot;CCUBRIDDataSource::GetLiteralInfo\n&quot;));
    ObjectLock lock(this);

    // 현재 오류객체를 제거한다.
    ClearError();

    // 초기화
    if( pcLiteralInfo )
        *pcLiteralInfo = 0;
    if( prgLiteralInfo )
        *prgLiteralInfo = NULL;
    if( ppCharBuffer )
        *ppCharBuffer = NULL;
        
    // 파라미터 체크
    if (!pcLiteralInfo || !prgLiteralInfo || !ppCharBuffer)
        return E_INVALIDARG;
    if( cLiterals != 0 &amp;&amp; rgLiterals == NULL )
        return E_INVALIDARG;

    // Data Source가 초기화 되었는지 확인
    if (!(m_dwStatus &amp; DSF_INITIALIZED))
        return E_UNEXPECTED;

    *ppCharBuffer = (WCHAR *)CoTaskMemAlloc(ProvInfo::size_wszAllStrings);
    if(*ppCharBuffer==NULL) return E_OUTOFMEMORY;
    memcpy(*ppCharBuffer, ProvInfo::wszAllStrings, ProvInfo::size_wszAllStrings);

    // 제공되는 모두 literal 정보 수
   const UINT numLiteralInfos = ProvInfo::size_LiteralInfos;

    // cLiterals가 0이면 모든 literal 정보 리턴
    *pcLiteralInfo = ( cLiterals==0 ? numLiteralInfos : cLiterals );

    // *pcLiteralInfo 만큼의 DBLITERALINFO 구조체 배열 할당
   *prgLiteralInfo = (DBLITERALINFO *)CoTaskMemAlloc(*pcLiteralInfo * sizeof(DBLITERALINFO));
    if (!*prgLiteralInfo)
    {
        ::CoTaskMemFree(*ppCharBuffer);
        *pcLiteralInfo = 0;
        *ppCharBuffer = 0;
        return E_OUTOFMEMORY;
    }

    ULONG ulSucceeded = 0;
    if(cLiterals)
    {   // 일부 literal 정보만 반환
        for(ULONG i=0;i&lt;*pcLiteralInfo;i++)
        {
            ULONG j;
            // 요청된 literal이 LiteralInfos에 있는지 찾아본다.
            for(j=0;j&lt;numLiteralInfos;j++)
            {
                if(ProvInfo::LiteralInfos[j].lt==rgLiterals[i])
                {
                    (*prgLiteralInfo)[i] = ProvInfo::LiteralInfos[j];
                    ulSucceeded++;
                    break;
                }
            }

            if(j==numLiteralInfos)
            {   // LiteralInfos에 없는 literal
                // fSupported도 자동으로 FALSE가 된다.
                ZeroMemory((*prgLiteralInfo)+i, sizeof(DBLITERALINFO));
                (*prgLiteralInfo)[i].lt = rgLiterals[i];
            }
        }
    }
    else
    {   // 모든 literal 정보를 반환
        for( ; ulSucceeded&lt;numLiteralInfos ; ulSucceeded++ )
            (*prgLiteralInfo)[ulSucceeded] = ProvInfo::LiteralInfos[ulSucceeded];
    }

    if(ulSucceeded==*pcLiteralInfo)
        return S_OK;
    else if(ulSucceeded!=0)
        return DB_S_ERRORSOCCURRED;
    else
    {
        // 스펙에 따라서 string buffer는 free하고, infos buffer는 놔둔다.
        ::CoTaskMemFree(*ppCharBuffer);
        *ppCharBuffer = NULL;
        return DB_E_ERRORSOCCURRED;
    }
}

STDMETHODIMP CCUBRIDDataSource::GetKeywords(LPOLESTR *ppwszKeywords)
{
    ATLTRACE(atlTraceDBProvider, 2, _T(&quot;CCUBRIDDataSource::GetKeywords\n&quot;));
    ObjectLock lock(this);
    
    // 현재 오류객체를 제거한다.
    ClearError();

    // check params
    if (ppwszKeywords == NULL)
        return E_INVALIDARG;
    *ppwszKeywords = NULL;
    
    // check if data source object is initialized
    if (!(m_dwStatus &amp; DSF_INITIALIZED))
        return E_UNEXPECTED;

    // 키워드 리스트를 comma를 seperate 문자로 하여 continuous한 배열로 선언
  OLECHAR Keywords[] = L&quot;ABORT,ACTIVE,ADD_MONTHS,AFTER,ALIAS,ASYNC,ATTACH,ATTRIBUTE,&quot;
                         L&quot;BEFORE,BOOLEAN,BREADTH,CALL,CHANGE,CLASS,CLASSES,CLUSTER,&quot;
                         L&quot;COMMITTED,COMPLETION,COST,CYCLE,DATA,DATA_TYPE___,DECAY_CONSTANT,&quot;
                         L&quot;DEFINED,DEPTH,DICTIONARY,DIFFERENCE,DIRECTORY,DRAND,EACH,&quot;
                         L&quot;ELSEIF,EQUALS,EVALUATE,EVENT,EXCLUDE,FILE,FUNCTION,GDB,GENERAL,&quot;
                         L&quot;GROUPBY_NUM,GROUPS,HOST,IDENTIFIED,IF,IGNORE,INACTIVE,INCREMENT,&quot;
                         L&quot;INDEX,INFINITE,INHERIT,INOUT,INSTANCES,INST_NUM,&quot;
                         L&quot;INTERSECTION,INTRINSIC,INVALIDATE,LAST_DAY,LDB,LEAVE,LESS,LIMIT,LIST,&quot;
                         L&quot;LOCK,LOOP,LPAD,LTRIM,MAXIMUM,MAXVALUE,MAX_ACTIVE,&quot;
                         L&quot;MEMBERS,METHOD,MINVALUE,MIN_ACTIVE,MODIFY,MOD,MONETARY,&quot;
                         L&quot;MONTHS_BETWEEN,MULTISET,MULTISET_OF,NA,NAME,&quot;
                         L&quot;NEW,NOCYCLE,NOMAXVALUE,NOMINVALUE,NONE,OBJECT,OBJECT_ID,OFF,OID,OLD,&quot;
                         L&quot;OPERATION,OPERATORS,OPTIMIZATION,ORDERBY_NUM,OTHERS,OUT,PARAMETERS,&quot;
                         L&quot;PASSWORD,PENDANT,PREORDER,PRINT,PRIORITY,PRIVATE,PROXY,PROTECTED,&quot;
                         L&quot;QUERY,RAND,RECURSIVE,REF,REFERENCING,REGISTER,REJECT,RENAME,REPEATABLE,&quot;
                         L&quot;REPLACE,RESIGNAL,RETURN,RETURNS,ROLE,ROUTINE,ROW,ROWNUM,&quot;
                         L&quot;RPAD,RTRIM,SAVEPOINT,SCOPE___,SEARCH,SENSITIVE,SEQUENCE,&quot;
                         L&quot;SEQUENCE_OF,SERIAL,SERIALIZABLE,SETEQ,SETNEQ,SET_OF,SHARED,SHORT,SIGNAL,&quot;
                         L&quot;SIMILAR,SQLEXCEPTION,SQLWARNING,STABILITY,START,STATEMENT,STATISTICS,STATUS,&quot;
                         L&quot;STDDEV,STRING,STRUCTURE,SUBCLASS,SUBSET,SUBSETEQ,SUPERCLASS,&quot;
                         L&quot;SUPERSET,SUPERSETEQ,SYS_DATE,SYS_TIME,SYS_TIMESTAMP,SYS_USER,&quot;
                         L&quot;TEST,THERE,TIMEOUT,TO_CHAR,TO_DATE,TO_NUMBER,TO_TIMETO_TIMESTAMP,&quot;
                         L&quot;TRACE,TRIGGERS,TYPE,UNDER,USE,UTIME,VARIABLE,VARIANCE,&quot;
                         L&quot;VCLASS,VIRTUAL,VISIBLE,WAIT,WHILE,WITHOUT&quot;;

    // 버퍼를 생성한다 
    *ppwszKeywords = (LPWSTR)CoTaskMemAlloc(sizeof(Keywords));
    if( *ppwszKeywords == NULL )
        return E_OUTOFMEMORY;

    // Copy keywords
    wcscpy( *ppwszKeywords, Keywords );
    
    return S_OK;
}
</span></div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;        <span class="comment">// DBPROPFLAGS_CHANGE flag를 추가한다.</span></div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;        var = dbmsver;</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;        <a class="code" href="classCUtlProps.html#a65763fbb6841a5b66fb0cd96b9a01fc9">SetPropValue</a>(&amp;DBPROPSET_DATASOURCEINFO, DBPROP_DBMSVER, &amp;var);</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;        VariantClear(&amp;var);</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;        VariantInit(&amp;var);</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;        var = <span class="stringliteral">&quot;2.0.01.004&quot;</span>;</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;        <a class="code" href="classCUtlProps.html#a65763fbb6841a5b66fb0cd96b9a01fc9">SetPropValue</a>(&amp;DBPROPSET_DATASOURCEINFO, DBPROP_PROVIDERVER, &amp;var);</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;        <a class="code" href="classCUtlProps.html#acaa05098d3993e594f7c2e8c4e0b14e5">GetPropValue</a>(&amp;DBPROPSET_DBINIT, DBPROP_INIT_LOCATION, &amp;var);</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;        <a class="code" href="classCUtlProps.html#a65763fbb6841a5b66fb0cd96b9a01fc9">SetPropValue</a>(&amp;DBPROPSET_DATASOURCEINFO, DBPROP_DATASOURCENAME, &amp;var);</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;        var = DBPROPVAL_CS_INITIALIZED;</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;        <a class="code" href="classCUtlProps.html#a65763fbb6841a5b66fb0cd96b9a01fc9">SetPropValue</a>(&amp;DBPROPSET_DATASOURCEINFO, DBPROP_CONNECTIONSTATUS, &amp;var);</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;        </div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;    }</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="atldb__cubrid_8h.html#a1c8f62bc38a50376a62d4dad41a5e2aa">S_OK</a>;</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;}</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;</div><div class="line"><a name="l00140"></a><span class="lineno"><a class="line" href="classCCUBRIDDataSource.html#aeb6fb1c9b1dafebed603ed51c86f26c1">  140</a></span>&#160;STDMETHODIMP <a class="code" href="classCCUBRIDDataSource.html#aeb6fb1c9b1dafebed603ed51c86f26c1">CCUBRIDDataSource::Uninitialize</a>(<span class="keywordtype">void</span>)</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;{</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;    ATLTRACE2(atlTraceDBProvider, 2, <span class="stringliteral">&quot;CCUBRIDDataSource::Uninitialize\n&quot;</span>);</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;    CComVariant var;</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;    <span class="comment">// 현재 오류객체를 제거한다.</span></div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;    <a class="code" href="Error_8cpp.html#a93f7a306ed9bf1f41de89f2afea7f55d">ClearError</a>();</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;    <span class="comment">// ATL의 루틴을 호출</span></div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;    {</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;        HRESULT hr = <a class="code" href="classIDBInitializeImpl.html#ac3d11ba98f71e86cf15a8ee02708b50d">IDBInitializeImpl&lt;CCUBRIDDataSource&gt;::Uninitialize</a>();</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;        <span class="keywordflow">if</span>(FAILED(hr)) <span class="keywordflow">return</span> hr;</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;    }</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;    var = <a class="code" href="classCCUBRIDDataSource.html#ac7add4a02fc27edc2b92f6a25d0a2429">DBPROPVAL_CS_UNINITIALIZED</a>;</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;    <a class="code" href="classCUtlProps.html#a65763fbb6841a5b66fb0cd96b9a01fc9">SetPropValue</a>(&amp;DBPROPSET_DATASOURCEINFO, DBPROP_CONNECTIONSTATUS, &amp;var);</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="atldb__cubrid_8h.html#a1c8f62bc38a50376a62d4dad41a5e2aa">S_OK</a>;</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;}</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;</div><div class="line"><a name="l00161"></a><span class="lineno"><a class="line" href="classCCUBRIDDataSource.html#a6150ec7ab9bf9d29584095f1a9db6a77">  161</a></span>&#160;STDMETHODIMP <a class="code" href="classCCUBRIDDataSource.html#a6150ec7ab9bf9d29584095f1a9db6a77">CCUBRIDDataSource::CreateSession</a>(IUnknown *pUnkOuter, REFIID riid, IUnknown **ppDBSession)</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;{</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;    <span class="keywordflow">if</span>(ppDBSession==<a class="code" href="freelistheap_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) <span class="keywordflow">return</span> E_INVALIDARG;</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;    *ppDBSession = <a class="code" href="freelistheap_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;    <span class="comment">// DBPROP_ACTIVESESSIONS 개수 이상의 session을 열 수 없다.</span></div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;    {</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;        CComVariant var;</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;        HRESULT hr = <a class="code" href="classCUtlProps.html#acaa05098d3993e594f7c2e8c4e0b14e5">GetPropValue</a>(&amp;DBPROPSET_DATASOURCEINFO, DBPROP_ACTIVESESSIONS, &amp;var);</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;        <span class="keywordflow">if</span>(FAILED(hr)) <span class="keywordflow">return</span> hr;</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;        ATLASSERT(var.vt==VT_I4);</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;        <span class="keywordtype">int</span> cActSessions = V_I4(&amp;var);</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;        <span class="keywordflow">if</span>(cActSessions!=0 &amp;&amp; this-&gt;<a class="code" href="classIDBInitializeImpl.html#a2402639b9a6fd4a8bb50a332933f817f">m_cSessionsOpen</a>&gt;=cActSessions)</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;            <span class="keywordflow">return</span> DB_E_OBJECTCREATIONLIMITREACHED;</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;    }</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;    <span class="comment">// DBPROP_MULTIPLECONNECTIONS==FALSE면   // 여러 개의 connection handle을 여는 것을 허용하지 않음
    /*
    {
        CComVariant var;
        HRESULT hr = GetPropValue(&amp;DBPROPSET_DATASOURCE, DBPROP_MULTIPLECONNECTIONS, &amp;var);
        if(FAILED(hr)) return hr;

        ATLASSERT(var.vt==VT_BOOL);
        bool bMulSessions = V_BOOL(&amp;var);

        if(!bMulSessions &amp;&amp; this-&gt;m_cSessionsOpen!=0)
            return DB_E_OBJECTOPEN;
    }
    */

    return IDBCreateSessionImpl&lt;CCUBRIDDataSource, CCUBRIDSession&gt;::CreateSession(pUnkOuter, riid, ppDBSession);
}

STDMETHODIMP CCUBRIDDataSource::GetLiteralInfo(ULONG cLiterals, const DBLITERAL rgLiterals[],
                              ULONG *pcLiteralInfo, DBLITERALINFO **prgLiteralInfo,
                              OLECHAR **ppCharBuffer)
{
    ATLTRACE(atlTraceDBProvider, 2, _T(&quot;CCUBRIDDataSource::GetLiteralInfo\n&quot;));
    ObjectLock lock(this);

    // 현재 오류객체를 제거한다.
    ClearError();

    // 초기화
    if( pcLiteralInfo )
        *pcLiteralInfo = 0;
    if( prgLiteralInfo )
        *prgLiteralInfo = NULL;
    if( ppCharBuffer )
        *ppCharBuffer = NULL;
        
    // 파라미터 체크
    if (!pcLiteralInfo || !prgLiteralInfo || !ppCharBuffer)
        return E_INVALIDARG;
    if( cLiterals != 0 &amp;&amp; rgLiterals == NULL )
        return E_INVALIDARG;

    // Data Source가 초기화 되었는지 확인
    if (!(m_dwStatus &amp; DSF_INITIALIZED))
        return E_UNEXPECTED;

    *ppCharBuffer = (WCHAR *)CoTaskMemAlloc(ProvInfo::size_wszAllStrings);
    if(*ppCharBuffer==NULL) return E_OUTOFMEMORY;
    memcpy(*ppCharBuffer, ProvInfo::wszAllStrings, ProvInfo::size_wszAllStrings);

    // 제공되는 모두 literal 정보 수
   const UINT numLiteralInfos = ProvInfo::size_LiteralInfos;

    // cLiterals가 0이면 모든 literal 정보 리턴
    *pcLiteralInfo = ( cLiterals==0 ? numLiteralInfos : cLiterals );

    // *pcLiteralInfo 만큼의 DBLITERALINFO 구조체 배열 할당
   *prgLiteralInfo = (DBLITERALINFO *)CoTaskMemAlloc(*pcLiteralInfo * sizeof(DBLITERALINFO));
    if (!*prgLiteralInfo)
    {
        ::CoTaskMemFree(*ppCharBuffer);
        *pcLiteralInfo = 0;
        *ppCharBuffer = 0;
        return E_OUTOFMEMORY;
    }

    ULONG ulSucceeded = 0;
    if(cLiterals)
    {   // 일부 literal 정보만 반환
        for(ULONG i=0;i&lt;*pcLiteralInfo;i++)
        {
            ULONG j;
            // 요청된 literal이 LiteralInfos에 있는지 찾아본다.
            for(j=0;j&lt;numLiteralInfos;j++)
            {
                if(ProvInfo::LiteralInfos[j].lt==rgLiterals[i])
                {
                    (*prgLiteralInfo)[i] = ProvInfo::LiteralInfos[j];
                    ulSucceeded++;
                    break;
                }
            }

            if(j==numLiteralInfos)
            {   // LiteralInfos에 없는 literal
                // fSupported도 자동으로 FALSE가 된다.
                ZeroMemory((*prgLiteralInfo)+i, sizeof(DBLITERALINFO));
                (*prgLiteralInfo)[i].lt = rgLiterals[i];
            }
        }
    }
    else
    {   // 모든 literal 정보를 반환
        for( ; ulSucceeded&lt;numLiteralInfos ; ulSucceeded++ )
            (*prgLiteralInfo)[ulSucceeded] = ProvInfo::LiteralInfos[ulSucceeded];
    }

    if(ulSucceeded==*pcLiteralInfo)
        return S_OK;
    else if(ulSucceeded!=0)
        return DB_S_ERRORSOCCURRED;
    else
    {
        // 스펙에 따라서 string buffer는 free하고, infos buffer는 놔둔다.
        ::CoTaskMemFree(*ppCharBuffer);
        *ppCharBuffer = NULL;
        return DB_E_ERRORSOCCURRED;
    }
}

STDMETHODIMP CCUBRIDDataSource::GetKeywords(LPOLESTR *ppwszKeywords)
{
    ATLTRACE(atlTraceDBProvider, 2, _T(&quot;CCUBRIDDataSource::GetKeywords\n&quot;));
    ObjectLock lock(this);
    
    // 현재 오류객체를 제거한다.
    ClearError();

    // check params
    if (ppwszKeywords == NULL)
        return E_INVALIDARG;
    *ppwszKeywords = NULL;
    
    // check if data source object is initialized
    if (!(m_dwStatus &amp; DSF_INITIALIZED))
        return E_UNEXPECTED;

    // 키워드 리스트를 comma를 seperate 문자로 하여 continuous한 배열로 선언
  OLECHAR Keywords[] = L&quot;ABORT,ACTIVE,ADD_MONTHS,AFTER,ALIAS,ASYNC,ATTACH,ATTRIBUTE,&quot;
                         L&quot;BEFORE,BOOLEAN,BREADTH,CALL,CHANGE,CLASS,CLASSES,CLUSTER,&quot;
                         L&quot;COMMITTED,COMPLETION,COST,CYCLE,DATA,DATA_TYPE___,DECAY_CONSTANT,&quot;
                         L&quot;DEFINED,DEPTH,DICTIONARY,DIFFERENCE,DIRECTORY,DRAND,EACH,&quot;
                         L&quot;ELSEIF,EQUALS,EVALUATE,EVENT,EXCLUDE,FILE,FUNCTION,GDB,GENERAL,&quot;
                         L&quot;GROUPBY_NUM,GROUPS,HOST,IDENTIFIED,IF,IGNORE,INACTIVE,INCREMENT,&quot;
                         L&quot;INDEX,INFINITE,INHERIT,INOUT,INSTANCES,INST_NUM,&quot;
                         L&quot;INTERSECTION,INTRINSIC,INVALIDATE,LAST_DAY,LDB,LEAVE,LESS,LIMIT,LIST,&quot;
                         L&quot;LOCK,LOOP,LPAD,LTRIM,MAXIMUM,MAXVALUE,MAX_ACTIVE,&quot;
                         L&quot;MEMBERS,METHOD,MINVALUE,MIN_ACTIVE,MODIFY,MOD,MONETARY,&quot;
                         L&quot;MONTHS_BETWEEN,MULTISET,MULTISET_OF,NA,NAME,&quot;
                         L&quot;NEW,NOCYCLE,NOMAXVALUE,NOMINVALUE,NONE,OBJECT,OBJECT_ID,OFF,OID,OLD,&quot;
                         L&quot;OPERATION,OPERATORS,OPTIMIZATION,ORDERBY_NUM,OTHERS,OUT,PARAMETERS,&quot;
                         L&quot;PASSWORD,PENDANT,PREORDER,PRINT,PRIORITY,PRIVATE,PROXY,PROTECTED,&quot;
                         L&quot;QUERY,RAND,RECURSIVE,REF,REFERENCING,REGISTER,REJECT,RENAME,REPEATABLE,&quot;
                         L&quot;REPLACE,RESIGNAL,RETURN,RETURNS,ROLE,ROUTINE,ROW,ROWNUM,&quot;
                         L&quot;RPAD,RTRIM,SAVEPOINT,SCOPE___,SEARCH,SENSITIVE,SEQUENCE,&quot;
                         L&quot;SEQUENCE_OF,SERIAL,SERIALIZABLE,SETEQ,SETNEQ,SET_OF,SHARED,SHORT,SIGNAL,&quot;
                         L&quot;SIMILAR,SQLEXCEPTION,SQLWARNING,STABILITY,START,STATEMENT,STATISTICS,STATUS,&quot;
                         L&quot;STDDEV,STRING,STRUCTURE,SUBCLASS,SUBSET,SUBSETEQ,SUPERCLASS,&quot;
                         L&quot;SUPERSET,SUPERSETEQ,SYS_DATE,SYS_TIME,SYS_TIMESTAMP,SYS_USER,&quot;
                         L&quot;TEST,THERE,TIMEOUT,TO_CHAR,TO_DATE,TO_NUMBER,TO_TIMETO_TIMESTAMP,&quot;
                         L&quot;TRACE,TRIGGERS,TYPE,UNDER,USE,UTIME,VARIABLE,VARIANCE,&quot;
                         L&quot;VCLASS,VIRTUAL,VISIBLE,WAIT,WHILE,WITHOUT&quot;;

    // 버퍼를 생성한다 
    *ppwszKeywords = (LPWSTR)CoTaskMemAlloc(sizeof(Keywords));
    if( *ppwszKeywords == NULL )
        return E_OUTOFMEMORY;

    // Copy keywords
    wcscpy( *ppwszKeywords, Keywords );
    
    return S_OK;
}
</span></div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;    <span class="comment">// 여러 개의 connection handle을 여는 것을 허용하지 않음</span></div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;    <span class="comment">/*</span></div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;<span class="comment">    {</span></div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;<span class="comment">        CComVariant var;</span></div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;<span class="comment">        HRESULT hr = GetPropValue(&amp;DBPROPSET_DATASOURCE, DBPROP_MULTIPLECONNECTIONS, &amp;var);</span></div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;<span class="comment">        if(FAILED(hr)) return hr;</span></div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;<span class="comment">        ATLASSERT(var.vt==VT_BOOL);</span></div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;<span class="comment">        bool bMulSessions = V_BOOL(&amp;var);</span></div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;<span class="comment">        if(!bMulSessions &amp;&amp; this-&gt;m_cSessionsOpen!=0)</span></div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;<span class="comment">            return DB_E_OBJECTOPEN;</span></div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;<span class="comment">    }</span></div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;<span class="comment">    */</span></div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="classIDBCreateSessionImpl.html#a45da236fb4f240f09914a5dc86ba2683">IDBCreateSessionImpl&lt;CCUBRIDDataSource, CCUBRIDSession&gt;::CreateSession</a>(pUnkOuter, riid, ppDBSession);</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;}</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;</div><div class="line"><a name="l00198"></a><span class="lineno"><a class="line" href="classCCUBRIDDataSource.html#af7e635787e2538b2259ea054254934c8">  198</a></span>&#160;STDMETHODIMP <a class="code" href="classCCUBRIDDataSource.html#af7e635787e2538b2259ea054254934c8">CCUBRIDDataSource::GetLiteralInfo</a>(ULONG cLiterals, <span class="keyword">const</span> DBLITERAL rgLiterals[],</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;                              ULONG *pcLiteralInfo, DBLITERALINFO **prgLiteralInfo,</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;                              OLECHAR **ppCharBuffer)</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;{</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;    ATLTRACE(atlTraceDBProvider, 2, _T(<span class="stringliteral">&quot;CCUBRIDDataSource::GetLiteralInfo\n&quot;</span>));</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;    ObjectLock lock(<span class="keyword">this</span>);</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;    <span class="comment">// 현재 오류객체를 제거한다.</span></div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;    <a class="code" href="Error_8cpp.html#a93f7a306ed9bf1f41de89f2afea7f55d">ClearError</a>();</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;    <span class="comment">// 초기화</span></div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;    <span class="keywordflow">if</span>( pcLiteralInfo )</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;        *pcLiteralInfo = 0;</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;    <span class="keywordflow">if</span>( prgLiteralInfo )</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;        *prgLiteralInfo = <a class="code" href="freelistheap_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;    <span class="keywordflow">if</span>( ppCharBuffer )</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;        *ppCharBuffer = <a class="code" href="freelistheap_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;        </div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;    <span class="comment">// 파라미터 체크</span></div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;    <span class="keywordflow">if</span> (!pcLiteralInfo || !prgLiteralInfo || !ppCharBuffer)</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;        <span class="keywordflow">return</span> E_INVALIDARG;</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;    <span class="keywordflow">if</span>( cLiterals != 0 &amp;&amp; rgLiterals == <a class="code" href="freelistheap_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a> )</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;        <span class="keywordflow">return</span> E_INVALIDARG;</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;    <span class="comment">// Data Source가 초기화 되었는지 확인</span></div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;    <span class="keywordflow">if</span> (!(<a class="code" href="classIDBInitializeImpl.html#a16244ce38ecd287e65a5002e824cda6e">m_dwStatus</a> &amp; <a class="code" href="atldb__cubrid_8h.html#a4fccd5948653ba2d16fd2630803c94dda26437abf36c5c1502da84a9fac2aae89">DSF_INITIALIZED</a>))</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;        <span class="keywordflow">return</span> E_UNEXPECTED;</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;    *ppCharBuffer = (WCHAR *)CoTaskMemAlloc(<a class="code" href="namespaceProvInfo.html#a2ec67ab60182be7ccd99afa3e2182ae0">ProvInfo::size_wszAllStrings</a>);</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;    <span class="keywordflow">if</span>(*ppCharBuffer==<a class="code" href="freelistheap_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) <span class="keywordflow">return</span> <a class="code" href="atldb__cubrid_8h.html#a384404dfdbf1a0d41047dbe021b216d7">E_OUTOFMEMORY</a>;</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;    memcpy(*ppCharBuffer, <a class="code" href="namespaceProvInfo.html#a5332020d8ad7633a5ba86e21dcb11e99">ProvInfo::wszAllStrings</a>, <a class="code" href="namespaceProvInfo.html#a2ec67ab60182be7ccd99afa3e2182ae0">ProvInfo::size_wszAllStrings</a>);</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;    <span class="comment">// 제공되는 모두 literal 정보 수    const UINT numLiteralInfos = ProvInfo::size_LiteralInfos;

    // cLiterals가 0이면 모든 literal 정보 리턴
    *pcLiteralInfo = ( cLiterals==0 ? numLiteralInfos : cLiterals );

    // *pcLiteralInfo 만큼의 DBLITERALINFO 구조체 배열 할당
   *prgLiteralInfo = (DBLITERALINFO *)CoTaskMemAlloc(*pcLiteralInfo * sizeof(DBLITERALINFO));
    if (!*prgLiteralInfo)
    {
        ::CoTaskMemFree(*ppCharBuffer);
        *pcLiteralInfo = 0;
        *ppCharBuffer = 0;
        return E_OUTOFMEMORY;
    }

    ULONG ulSucceeded = 0;
    if(cLiterals)
    {   // 일부 literal 정보만 반환
        for(ULONG i=0;i&lt;*pcLiteralInfo;i++)
        {
            ULONG j;
            // 요청된 literal이 LiteralInfos에 있는지 찾아본다.
            for(j=0;j&lt;numLiteralInfos;j++)
            {
                if(ProvInfo::LiteralInfos[j].lt==rgLiterals[i])
                {
                    (*prgLiteralInfo)[i] = ProvInfo::LiteralInfos[j];
                    ulSucceeded++;
                    break;
                }
            }

            if(j==numLiteralInfos)
            {   // LiteralInfos에 없는 literal
                // fSupported도 자동으로 FALSE가 된다.
                ZeroMemory((*prgLiteralInfo)+i, sizeof(DBLITERALINFO));
                (*prgLiteralInfo)[i].lt = rgLiterals[i];
            }
        }
    }
    else
    {   // 모든 literal 정보를 반환
        for( ; ulSucceeded&lt;numLiteralInfos ; ulSucceeded++ )
            (*prgLiteralInfo)[ulSucceeded] = ProvInfo::LiteralInfos[ulSucceeded];
    }

    if(ulSucceeded==*pcLiteralInfo)
        return S_OK;
    else if(ulSucceeded!=0)
        return DB_S_ERRORSOCCURRED;
    else
    {
        // 스펙에 따라서 string buffer는 free하고, infos buffer는 놔둔다.
        ::CoTaskMemFree(*ppCharBuffer);
        *ppCharBuffer = NULL;
        return DB_E_ERRORSOCCURRED;
    }
}

STDMETHODIMP CCUBRIDDataSource::GetKeywords(LPOLESTR *ppwszKeywords)
{
    ATLTRACE(atlTraceDBProvider, 2, _T(&quot;CCUBRIDDataSource::GetKeywords\n&quot;));
    ObjectLock lock(this);
    
    // 현재 오류객체를 제거한다.
    ClearError();

    // check params
    if (ppwszKeywords == NULL)
        return E_INVALIDARG;
    *ppwszKeywords = NULL;
    
    // check if data source object is initialized
    if (!(m_dwStatus &amp; DSF_INITIALIZED))
        return E_UNEXPECTED;

    // 키워드 리스트를 comma를 seperate 문자로 하여 continuous한 배열로 선언
  OLECHAR Keywords[] = L&quot;ABORT,ACTIVE,ADD_MONTHS,AFTER,ALIAS,ASYNC,ATTACH,ATTRIBUTE,&quot;
                         L&quot;BEFORE,BOOLEAN,BREADTH,CALL,CHANGE,CLASS,CLASSES,CLUSTER,&quot;
                         L&quot;COMMITTED,COMPLETION,COST,CYCLE,DATA,DATA_TYPE___,DECAY_CONSTANT,&quot;
                         L&quot;DEFINED,DEPTH,DICTIONARY,DIFFERENCE,DIRECTORY,DRAND,EACH,&quot;
                         L&quot;ELSEIF,EQUALS,EVALUATE,EVENT,EXCLUDE,FILE,FUNCTION,GDB,GENERAL,&quot;
                         L&quot;GROUPBY_NUM,GROUPS,HOST,IDENTIFIED,IF,IGNORE,INACTIVE,INCREMENT,&quot;
                         L&quot;INDEX,INFINITE,INHERIT,INOUT,INSTANCES,INST_NUM,&quot;
                         L&quot;INTERSECTION,INTRINSIC,INVALIDATE,LAST_DAY,LDB,LEAVE,LESS,LIMIT,LIST,&quot;
                         L&quot;LOCK,LOOP,LPAD,LTRIM,MAXIMUM,MAXVALUE,MAX_ACTIVE,&quot;
                         L&quot;MEMBERS,METHOD,MINVALUE,MIN_ACTIVE,MODIFY,MOD,MONETARY,&quot;
                         L&quot;MONTHS_BETWEEN,MULTISET,MULTISET_OF,NA,NAME,&quot;
                         L&quot;NEW,NOCYCLE,NOMAXVALUE,NOMINVALUE,NONE,OBJECT,OBJECT_ID,OFF,OID,OLD,&quot;
                         L&quot;OPERATION,OPERATORS,OPTIMIZATION,ORDERBY_NUM,OTHERS,OUT,PARAMETERS,&quot;
                         L&quot;PASSWORD,PENDANT,PREORDER,PRINT,PRIORITY,PRIVATE,PROXY,PROTECTED,&quot;
                         L&quot;QUERY,RAND,RECURSIVE,REF,REFERENCING,REGISTER,REJECT,RENAME,REPEATABLE,&quot;
                         L&quot;REPLACE,RESIGNAL,RETURN,RETURNS,ROLE,ROUTINE,ROW,ROWNUM,&quot;
                         L&quot;RPAD,RTRIM,SAVEPOINT,SCOPE___,SEARCH,SENSITIVE,SEQUENCE,&quot;
                         L&quot;SEQUENCE_OF,SERIAL,SERIALIZABLE,SETEQ,SETNEQ,SET_OF,SHARED,SHORT,SIGNAL,&quot;
                         L&quot;SIMILAR,SQLEXCEPTION,SQLWARNING,STABILITY,START,STATEMENT,STATISTICS,STATUS,&quot;
                         L&quot;STDDEV,STRING,STRUCTURE,SUBCLASS,SUBSET,SUBSETEQ,SUPERCLASS,&quot;
                         L&quot;SUPERSET,SUPERSETEQ,SYS_DATE,SYS_TIME,SYS_TIMESTAMP,SYS_USER,&quot;
                         L&quot;TEST,THERE,TIMEOUT,TO_CHAR,TO_DATE,TO_NUMBER,TO_TIMETO_TIMESTAMP,&quot;
                         L&quot;TRACE,TRIGGERS,TYPE,UNDER,USE,UTIME,VARIABLE,VARIANCE,&quot;
                         L&quot;VCLASS,VIRTUAL,VISIBLE,WAIT,WHILE,WITHOUT&quot;;

    // 버퍼를 생성한다 
    *ppwszKeywords = (LPWSTR)CoTaskMemAlloc(sizeof(Keywords));
    if( *ppwszKeywords == NULL )
        return E_OUTOFMEMORY;

    // Copy keywords
    wcscpy( *ppwszKeywords, Keywords );
    
    return S_OK;
}
</span></div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;    <span class="keyword">const</span> UINT numLiteralInfos = <a class="code" href="namespaceProvInfo.html#ac09fda6d1052a55d65a220f3649d405c">ProvInfo::size_LiteralInfos</a>;</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;    <span class="comment">// cLiterals가 0이면 모든 literal 정보 리턴</span></div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;    *pcLiteralInfo = ( cLiterals==0 ? numLiteralInfos : cLiterals );</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;    <span class="comment">// *pcLiteralInfo 만큼의 DBLITERALINFO 구조체 배열 할당    *prgLiteralInfo = (DBLITERALINFO *)CoTaskMemAlloc(*pcLiteralInfo * sizeof(DBLITERALINFO));
    if (!*prgLiteralInfo)
    {
        ::CoTaskMemFree(*ppCharBuffer);
        *pcLiteralInfo = 0;
        *ppCharBuffer = 0;
        return E_OUTOFMEMORY;
    }

    ULONG ulSucceeded = 0;
    if(cLiterals)
    {   // 일부 literal 정보만 반환
        for(ULONG i=0;i&lt;*pcLiteralInfo;i++)
        {
            ULONG j;
            // 요청된 literal이 LiteralInfos에 있는지 찾아본다.
            for(j=0;j&lt;numLiteralInfos;j++)
            {
                if(ProvInfo::LiteralInfos[j].lt==rgLiterals[i])
                {
                    (*prgLiteralInfo)[i] = ProvInfo::LiteralInfos[j];
                    ulSucceeded++;
                    break;
                }
            }

            if(j==numLiteralInfos)
            {   // LiteralInfos에 없는 literal
                // fSupported도 자동으로 FALSE가 된다.
                ZeroMemory((*prgLiteralInfo)+i, sizeof(DBLITERALINFO));
                (*prgLiteralInfo)[i].lt = rgLiterals[i];
            }
        }
    }
    else
    {   // 모든 literal 정보를 반환
        for( ; ulSucceeded&lt;numLiteralInfos ; ulSucceeded++ )
            (*prgLiteralInfo)[ulSucceeded] = ProvInfo::LiteralInfos[ulSucceeded];
    }

    if(ulSucceeded==*pcLiteralInfo)
        return S_OK;
    else if(ulSucceeded!=0)
        return DB_S_ERRORSOCCURRED;
    else
    {
        // 스펙에 따라서 string buffer는 free하고, infos buffer는 놔둔다.
        ::CoTaskMemFree(*ppCharBuffer);
        *ppCharBuffer = NULL;
        return DB_E_ERRORSOCCURRED;
    }
}

STDMETHODIMP CCUBRIDDataSource::GetKeywords(LPOLESTR *ppwszKeywords)
{
    ATLTRACE(atlTraceDBProvider, 2, _T(&quot;CCUBRIDDataSource::GetKeywords\n&quot;));
    ObjectLock lock(this);
    
    // 현재 오류객체를 제거한다.
    ClearError();

    // check params
    if (ppwszKeywords == NULL)
        return E_INVALIDARG;
    *ppwszKeywords = NULL;
    
    // check if data source object is initialized
    if (!(m_dwStatus &amp; DSF_INITIALIZED))
        return E_UNEXPECTED;

    // 키워드 리스트를 comma를 seperate 문자로 하여 continuous한 배열로 선언
  OLECHAR Keywords[] = L&quot;ABORT,ACTIVE,ADD_MONTHS,AFTER,ALIAS,ASYNC,ATTACH,ATTRIBUTE,&quot;
                         L&quot;BEFORE,BOOLEAN,BREADTH,CALL,CHANGE,CLASS,CLASSES,CLUSTER,&quot;
                         L&quot;COMMITTED,COMPLETION,COST,CYCLE,DATA,DATA_TYPE___,DECAY_CONSTANT,&quot;
                         L&quot;DEFINED,DEPTH,DICTIONARY,DIFFERENCE,DIRECTORY,DRAND,EACH,&quot;
                         L&quot;ELSEIF,EQUALS,EVALUATE,EVENT,EXCLUDE,FILE,FUNCTION,GDB,GENERAL,&quot;
                         L&quot;GROUPBY_NUM,GROUPS,HOST,IDENTIFIED,IF,IGNORE,INACTIVE,INCREMENT,&quot;
                         L&quot;INDEX,INFINITE,INHERIT,INOUT,INSTANCES,INST_NUM,&quot;
                         L&quot;INTERSECTION,INTRINSIC,INVALIDATE,LAST_DAY,LDB,LEAVE,LESS,LIMIT,LIST,&quot;
                         L&quot;LOCK,LOOP,LPAD,LTRIM,MAXIMUM,MAXVALUE,MAX_ACTIVE,&quot;
                         L&quot;MEMBERS,METHOD,MINVALUE,MIN_ACTIVE,MODIFY,MOD,MONETARY,&quot;
                         L&quot;MONTHS_BETWEEN,MULTISET,MULTISET_OF,NA,NAME,&quot;
                         L&quot;NEW,NOCYCLE,NOMAXVALUE,NOMINVALUE,NONE,OBJECT,OBJECT_ID,OFF,OID,OLD,&quot;
                         L&quot;OPERATION,OPERATORS,OPTIMIZATION,ORDERBY_NUM,OTHERS,OUT,PARAMETERS,&quot;
                         L&quot;PASSWORD,PENDANT,PREORDER,PRINT,PRIORITY,PRIVATE,PROXY,PROTECTED,&quot;
                         L&quot;QUERY,RAND,RECURSIVE,REF,REFERENCING,REGISTER,REJECT,RENAME,REPEATABLE,&quot;
                         L&quot;REPLACE,RESIGNAL,RETURN,RETURNS,ROLE,ROUTINE,ROW,ROWNUM,&quot;
                         L&quot;RPAD,RTRIM,SAVEPOINT,SCOPE___,SEARCH,SENSITIVE,SEQUENCE,&quot;
                         L&quot;SEQUENCE_OF,SERIAL,SERIALIZABLE,SETEQ,SETNEQ,SET_OF,SHARED,SHORT,SIGNAL,&quot;
                         L&quot;SIMILAR,SQLEXCEPTION,SQLWARNING,STABILITY,START,STATEMENT,STATISTICS,STATUS,&quot;
                         L&quot;STDDEV,STRING,STRUCTURE,SUBCLASS,SUBSET,SUBSETEQ,SUPERCLASS,&quot;
                         L&quot;SUPERSET,SUPERSETEQ,SYS_DATE,SYS_TIME,SYS_TIMESTAMP,SYS_USER,&quot;
                         L&quot;TEST,THERE,TIMEOUT,TO_CHAR,TO_DATE,TO_NUMBER,TO_TIMETO_TIMESTAMP,&quot;
                         L&quot;TRACE,TRIGGERS,TYPE,UNDER,USE,UTIME,VARIABLE,VARIANCE,&quot;
                         L&quot;VCLASS,VIRTUAL,VISIBLE,WAIT,WHILE,WITHOUT&quot;;

    // 버퍼를 생성한다 
    *ppwszKeywords = (LPWSTR)CoTaskMemAlloc(sizeof(Keywords));
    if( *ppwszKeywords == NULL )
        return E_OUTOFMEMORY;

    // Copy keywords
    wcscpy( *ppwszKeywords, Keywords );
    
    return S_OK;
}
</span></div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;    *prgLiteralInfo = (DBLITERALINFO *)CoTaskMemAlloc(*pcLiteralInfo * <span class="keyword">sizeof</span>(DBLITERALINFO));</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;    <span class="keywordflow">if</span> (!*prgLiteralInfo)</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;    {</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;        ::CoTaskMemFree(*ppCharBuffer);</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;        *pcLiteralInfo = 0;</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;        *ppCharBuffer = 0;</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="atldb__cubrid_8h.html#a384404dfdbf1a0d41047dbe021b216d7">E_OUTOFMEMORY</a>;</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;    }</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;    ULONG ulSucceeded = 0;</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;    <span class="keywordflow">if</span>(cLiterals)</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;    {   <span class="comment">// 일부 literal 정보만 반환</span></div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;        <span class="keywordflow">for</span>(ULONG <a class="code" href="dynamic__load_8c.html#acb559820d9ca11295b4500f179ef6392">i</a>=0;<a class="code" href="dynamic__load_8c.html#acb559820d9ca11295b4500f179ef6392">i</a>&lt;*pcLiteralInfo;<a class="code" href="dynamic__load_8c.html#acb559820d9ca11295b4500f179ef6392">i</a>++)</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;        {</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;            ULONG <a class="code" href="mprec_8c.html#abf2bc2545a4a5f5683d9ef3ed0d977e0">j</a>;</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;            <span class="comment">// 요청된 literal이 LiteralInfos에 있는지 찾아본다.</span></div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;            <span class="keywordflow">for</span>(<a class="code" href="mprec_8c.html#abf2bc2545a4a5f5683d9ef3ed0d977e0">j</a>=0;<a class="code" href="mprec_8c.html#abf2bc2545a4a5f5683d9ef3ed0d977e0">j</a>&lt;numLiteralInfos;<a class="code" href="mprec_8c.html#abf2bc2545a4a5f5683d9ef3ed0d977e0">j</a>++)</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;            {</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;                <span class="keywordflow">if</span>(<a class="code" href="namespaceProvInfo.html#ae4e7e35da6e101a63beb1eddd8f597bb">ProvInfo::LiteralInfos</a>[<a class="code" href="mprec_8c.html#abf2bc2545a4a5f5683d9ef3ed0d977e0">j</a>].lt==rgLiterals[<a class="code" href="dynamic__load_8c.html#acb559820d9ca11295b4500f179ef6392">i</a>])</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;                {</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;                    (*prgLiteralInfo)[<a class="code" href="dynamic__load_8c.html#acb559820d9ca11295b4500f179ef6392">i</a>] = <a class="code" href="namespaceProvInfo.html#ae4e7e35da6e101a63beb1eddd8f597bb">ProvInfo::LiteralInfos</a>[<a class="code" href="mprec_8c.html#abf2bc2545a4a5f5683d9ef3ed0d977e0">j</a>];</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;                    ulSucceeded++;</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;                    <span class="keywordflow">break</span>;</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;                }</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;            }</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;            <span class="keywordflow">if</span>(<a class="code" href="mprec_8c.html#abf2bc2545a4a5f5683d9ef3ed0d977e0">j</a>==numLiteralInfos)</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;            {   <span class="comment">// LiteralInfos에 없는 literal</span></div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;                <span class="comment">// fSupported도 자동으로 FALSE가 된다.</span></div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;                ZeroMemory((*prgLiteralInfo)+<a class="code" href="dynamic__load_8c.html#acb559820d9ca11295b4500f179ef6392">i</a>, <span class="keyword">sizeof</span>(DBLITERALINFO));</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;                (*prgLiteralInfo)[<a class="code" href="dynamic__load_8c.html#acb559820d9ca11295b4500f179ef6392">i</a>].lt = rgLiterals[<a class="code" href="dynamic__load_8c.html#acb559820d9ca11295b4500f179ef6392">i</a>];</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;            }</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;        }</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;    }</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;    {   <span class="comment">// 모든 literal 정보를 반환</span></div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;        <span class="keywordflow">for</span>( ; ulSucceeded&lt;numLiteralInfos ; ulSucceeded++ )</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;            (*prgLiteralInfo)[ulSucceeded] = <a class="code" href="namespaceProvInfo.html#ae4e7e35da6e101a63beb1eddd8f597bb">ProvInfo::LiteralInfos</a>[ulSucceeded];</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;    }</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;    <span class="keywordflow">if</span>(ulSucceeded==*pcLiteralInfo)</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="atldb__cubrid_8h.html#a1c8f62bc38a50376a62d4dad41a5e2aa">S_OK</a>;</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(ulSucceeded!=0)</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;        <span class="keywordflow">return</span> DB_S_ERRORSOCCURRED;</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;    {</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;        <span class="comment">// 스펙에 따라서 string buffer는 free하고, infos buffer는 놔둔다.</span></div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;        ::CoTaskMemFree(*ppCharBuffer);</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;        *ppCharBuffer = <a class="code" href="freelistheap_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;        <span class="keywordflow">return</span> DB_E_ERRORSOCCURRED;</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;    }</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;}</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;</div><div class="line"><a name="l00290"></a><span class="lineno"><a class="line" href="classCCUBRIDDataSource.html#a1550f3bbf6d47c1f185e6075c998f3da">  290</a></span>&#160;STDMETHODIMP <a class="code" href="classCCUBRIDDataSource.html#a1550f3bbf6d47c1f185e6075c998f3da">CCUBRIDDataSource::GetKeywords</a>(LPOLESTR *ppwszKeywords)</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;{</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;    ATLTRACE(atlTraceDBProvider, 2, _T(<span class="stringliteral">&quot;CCUBRIDDataSource::GetKeywords\n&quot;</span>));</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;    ObjectLock lock(<span class="keyword">this</span>);</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;    </div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;    <span class="comment">// 현재 오류객체를 제거한다.</span></div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;    <a class="code" href="Error_8cpp.html#a93f7a306ed9bf1f41de89f2afea7f55d">ClearError</a>();</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;    <span class="comment">// check params</span></div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;    <span class="keywordflow">if</span> (ppwszKeywords == <a class="code" href="freelistheap_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;        <span class="keywordflow">return</span> E_INVALIDARG;</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;    *ppwszKeywords = <a class="code" href="freelistheap_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;    </div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;    <span class="comment">// check if data source object is initialized</span></div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;    <span class="keywordflow">if</span> (!(<a class="code" href="classIDBInitializeImpl.html#a16244ce38ecd287e65a5002e824cda6e">m_dwStatus</a> &amp; <a class="code" href="atldb__cubrid_8h.html#a4fccd5948653ba2d16fd2630803c94dda26437abf36c5c1502da84a9fac2aae89">DSF_INITIALIZED</a>))</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;        <span class="keywordflow">return</span> E_UNEXPECTED;</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;    <span class="comment">// 키워드 리스트를 comma를 seperate 문자로 하여 continuous한 배열로 선언   OLECHAR Keywords[] = L&quot;ABORT,ACTIVE,ADD_MONTHS,AFTER,ALIAS,ASYNC,ATTACH,ATTRIBUTE,&quot;
                         L&quot;BEFORE,BOOLEAN,BREADTH,CALL,CHANGE,CLASS,CLASSES,CLUSTER,&quot;
                         L&quot;COMMITTED,COMPLETION,COST,CYCLE,DATA,DATA_TYPE___,DECAY_CONSTANT,&quot;
                         L&quot;DEFINED,DEPTH,DICTIONARY,DIFFERENCE,DIRECTORY,DRAND,EACH,&quot;
                         L&quot;ELSEIF,EQUALS,EVALUATE,EVENT,EXCLUDE,FILE,FUNCTION,GDB,GENERAL,&quot;
                         L&quot;GROUPBY_NUM,GROUPS,HOST,IDENTIFIED,IF,IGNORE,INACTIVE,INCREMENT,&quot;
                         L&quot;INDEX,INFINITE,INHERIT,INOUT,INSTANCES,INST_NUM,&quot;
                         L&quot;INTERSECTION,INTRINSIC,INVALIDATE,LAST_DAY,LDB,LEAVE,LESS,LIMIT,LIST,&quot;
                         L&quot;LOCK,LOOP,LPAD,LTRIM,MAXIMUM,MAXVALUE,MAX_ACTIVE,&quot;
                         L&quot;MEMBERS,METHOD,MINVALUE,MIN_ACTIVE,MODIFY,MOD,MONETARY,&quot;
                         L&quot;MONTHS_BETWEEN,MULTISET,MULTISET_OF,NA,NAME,&quot;
                         L&quot;NEW,NOCYCLE,NOMAXVALUE,NOMINVALUE,NONE,OBJECT,OBJECT_ID,OFF,OID,OLD,&quot;
                         L&quot;OPERATION,OPERATORS,OPTIMIZATION,ORDERBY_NUM,OTHERS,OUT,PARAMETERS,&quot;
                         L&quot;PASSWORD,PENDANT,PREORDER,PRINT,PRIORITY,PRIVATE,PROXY,PROTECTED,&quot;
                         L&quot;QUERY,RAND,RECURSIVE,REF,REFERENCING,REGISTER,REJECT,RENAME,REPEATABLE,&quot;
                         L&quot;REPLACE,RESIGNAL,RETURN,RETURNS,ROLE,ROUTINE,ROW,ROWNUM,&quot;
                         L&quot;RPAD,RTRIM,SAVEPOINT,SCOPE___,SEARCH,SENSITIVE,SEQUENCE,&quot;
                         L&quot;SEQUENCE_OF,SERIAL,SERIALIZABLE,SETEQ,SETNEQ,SET_OF,SHARED,SHORT,SIGNAL,&quot;
                         L&quot;SIMILAR,SQLEXCEPTION,SQLWARNING,STABILITY,START,STATEMENT,STATISTICS,STATUS,&quot;
                         L&quot;STDDEV,STRING,STRUCTURE,SUBCLASS,SUBSET,SUBSETEQ,SUPERCLASS,&quot;
                         L&quot;SUPERSET,SUPERSETEQ,SYS_DATE,SYS_TIME,SYS_TIMESTAMP,SYS_USER,&quot;
                         L&quot;TEST,THERE,TIMEOUT,TO_CHAR,TO_DATE,TO_NUMBER,TO_TIMETO_TIMESTAMP,&quot;
                         L&quot;TRACE,TRIGGERS,TYPE,UNDER,USE,UTIME,VARIABLE,VARIANCE,&quot;
                         L&quot;VCLASS,VIRTUAL,VISIBLE,WAIT,WHILE,WITHOUT&quot;;

    // 버퍼를 생성한다 
    *ppwszKeywords = (LPWSTR)CoTaskMemAlloc(sizeof(Keywords));
    if( *ppwszKeywords == NULL )
        return E_OUTOFMEMORY;

    // Copy keywords
    wcscpy( *ppwszKeywords, Keywords );
    
    return S_OK;
}
</span></div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;    OLECHAR Keywords[] = L<span class="stringliteral">&quot;ABORT,ACTIVE,ADD_MONTHS,AFTER,ALIAS,ASYNC,ATTACH,ATTRIBUTE,&quot;</span></div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;                         L<span class="stringliteral">&quot;BEFORE,BOOLEAN,BREADTH,CALL,CHANGE,CLASS,CLASSES,CLUSTER,&quot;</span></div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;                         L<span class="stringliteral">&quot;COMMITTED,COMPLETION,COST,CYCLE,DATA,DATA_TYPE___,DECAY_CONSTANT,&quot;</span></div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;                         L<span class="stringliteral">&quot;DEFINED,DEPTH,DICTIONARY,DIFFERENCE,DIRECTORY,DRAND,EACH,&quot;</span></div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;                         L<span class="stringliteral">&quot;ELSEIF,EQUALS,EVALUATE,EVENT,EXCLUDE,FILE,FUNCTION,GDB,GENERAL,&quot;</span></div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;                         L<span class="stringliteral">&quot;GROUPBY_NUM,GROUPS,HOST,IDENTIFIED,IF,IGNORE,INACTIVE,INCREMENT,&quot;</span></div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;                         L<span class="stringliteral">&quot;INDEX,INFINITE,INHERIT,INOUT,INSTANCES,INST_NUM,&quot;</span></div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;                         L<span class="stringliteral">&quot;INTERSECTION,INTRINSIC,INVALIDATE,LAST_DAY,LDB,LEAVE,LESS,LIMIT,LIST,&quot;</span></div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;                         L<span class="stringliteral">&quot;LOCK,LOOP,LPAD,LTRIM,MAXIMUM,MAXVALUE,MAX_ACTIVE,&quot;</span></div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;                         L<span class="stringliteral">&quot;MEMBERS,METHOD,MINVALUE,MIN_ACTIVE,MODIFY,MOD,MONETARY,&quot;</span></div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;                         L<span class="stringliteral">&quot;MONTHS_BETWEEN,MULTISET,MULTISET_OF,NA,NAME,&quot;</span></div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;                         L<span class="stringliteral">&quot;NEW,NOCYCLE,NOMAXVALUE,NOMINVALUE,NONE,OBJECT,OBJECT_ID,OFF,OID,OLD,&quot;</span></div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;                         L<span class="stringliteral">&quot;OPERATION,OPERATORS,OPTIMIZATION,ORDERBY_NUM,OTHERS,OUT,PARAMETERS,&quot;</span></div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;                         L<span class="stringliteral">&quot;PASSWORD,PENDANT,PREORDER,PRINT,PRIORITY,PRIVATE,PROXY,PROTECTED,&quot;</span></div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;                         L<span class="stringliteral">&quot;QUERY,RAND,RECURSIVE,REF,REFERENCING,REGISTER,REJECT,RENAME,REPEATABLE,&quot;</span></div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;                         L<span class="stringliteral">&quot;REPLACE,RESIGNAL,RETURN,RETURNS,ROLE,ROUTINE,ROW,ROWNUM,&quot;</span></div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;                         L<span class="stringliteral">&quot;RPAD,RTRIM,SAVEPOINT,SCOPE___,SEARCH,SENSITIVE,SEQUENCE,&quot;</span></div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;                         L<span class="stringliteral">&quot;SEQUENCE_OF,SERIAL,SERIALIZABLE,SETEQ,SETNEQ,SET_OF,SHARED,SHORT,SIGNAL,&quot;</span></div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;                         L<span class="stringliteral">&quot;SIMILAR,SQLEXCEPTION,SQLWARNING,STABILITY,START,STATEMENT,STATISTICS,STATUS,&quot;</span></div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;                         L<span class="stringliteral">&quot;STDDEV,STRING,STRUCTURE,SUBCLASS,SUBSET,SUBSETEQ,SUPERCLASS,&quot;</span></div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;                         L<span class="stringliteral">&quot;SUPERSET,SUPERSETEQ,SYS_DATE,SYS_TIME,SYS_TIMESTAMP,SYS_USER,&quot;</span></div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;                         L<span class="stringliteral">&quot;TEST,THERE,TIMEOUT,TO_CHAR,TO_DATE,TO_NUMBER,TO_TIMETO_TIMESTAMP,&quot;</span></div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;                         L<span class="stringliteral">&quot;TRACE,TRIGGERS,TYPE,UNDER,USE,UTIME,VARIABLE,VARIANCE,&quot;</span></div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;                         L<span class="stringliteral">&quot;VCLASS,VIRTUAL,VISIBLE,WAIT,WHILE,WITHOUT&quot;</span>;</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;    <span class="comment">// 버퍼를 생성한다 </span></div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;    *ppwszKeywords = (LPWSTR)CoTaskMemAlloc(<span class="keyword">sizeof</span>(Keywords));</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;    <span class="keywordflow">if</span>( *ppwszKeywords == <a class="code" href="freelistheap_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a> )</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="atldb__cubrid_8h.html#a384404dfdbf1a0d41047dbe021b216d7">E_OUTOFMEMORY</a>;</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;    <span class="comment">// Copy keywords</span></div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;    wcscpy( *ppwszKeywords, Keywords );</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;    </div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="atldb__cubrid_8h.html#a1c8f62bc38a50376a62d4dad41a5e2aa">S_OK</a>;</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;}</div><div class="ttc" id="cas__cci_8h_html_ad021d99d0eff7e3b483debe7ae0a67b0a62673d6fbc10807feb22ecf63cf2a014"><div class="ttname"><a href="cas__cci_8h.html#ad021d99d0eff7e3b483debe7ae0a67b0a62673d6fbc10807feb22ecf63cf2a014">CCI_ER_CON_HANDLE</a></div><div class="ttdef"><b>Definition:</b> <a href="cas__cci_8h_source.html#l00433">cas_cci.h:433</a></div></div>
<div class="ttc" id="classIDBInitializeImpl_html_a1a8b8105f2c6e9215cef57f2b934aa52"><div class="ttname"><a href="classIDBInitializeImpl.html#a1a8b8105f2c6e9215cef57f2b934aa52">IDBInitializeImpl::Initialize</a></div><div class="ttdeci">STDMETHOD() Initialize(void)</div><div class="ttdef"><b>Definition:</b> <a href="atldb__cubrid_8h_source.html#l02698">atldb_cubrid.h:2698</a></div></div>
<div class="ttc" id="mprec_8c_html_abf2bc2545a4a5f5683d9ef3ed0d977e0"><div class="ttname"><a href="mprec_8c.html#abf2bc2545a4a5f5683d9ef3ed0d977e0">j</a></div><div class="ttdeci">int j</div><div class="ttdef"><b>Definition:</b> <a href="mprec_8c_source.html#l00540">mprec.c:540</a></div></div>
<div class="ttc" id="namespaceUtil_html_aba4c685b27429329ec3ebc36c1a55024"><div class="ttname"><a href="namespaceUtil.html#aba4c685b27429329ec3ebc36c1a55024">Util::Connect</a></div><div class="ttdeci">HRESULT Connect(IDBProperties *pDBProps, int *phConn)</div><div class="ttdef"><b>Definition:</b> <a href="util_8cpp_source.html#l00072">util.cpp:72</a></div></div>
<div class="ttc" id="namespaceProvInfo_html_ae4e7e35da6e101a63beb1eddd8f597bb"><div class="ttname"><a href="namespaceProvInfo.html#ae4e7e35da6e101a63beb1eddd8f597bb">ProvInfo::LiteralInfos</a></div><div class="ttdeci">DBLITERALINFO LiteralInfos[]</div><div class="ttdef"><b>Definition:</b> <a href="ProviderInfo_8cpp_source.html#l00061">ProviderInfo.cpp:61</a></div></div>
<div class="ttc" id="namespaceProvInfo_html_a2ec67ab60182be7ccd99afa3e2182ae0"><div class="ttname"><a href="namespaceProvInfo.html#a2ec67ab60182be7ccd99afa3e2182ae0">ProvInfo::size_wszAllStrings</a></div><div class="ttdeci">int size_wszAllStrings</div><div class="ttdef"><b>Definition:</b> <a href="ProviderInfo_8cpp_source.html#l00047">ProviderInfo.cpp:47</a></div></div>
<div class="ttc" id="cas__cci_8c_html_ad388b647a3df564cb7daaec00c10418d"><div class="ttname"><a href="cas__cci_8c.html#ad388b647a3df564cb7daaec00c10418d">cci_get_db_version</a></div><div class="ttdeci">int cci_get_db_version(int mapped_conn_id, char *out_buf, int buf_size)</div><div class="ttdef"><b>Definition:</b> <a href="cas__cci_8c_source.html#l02783">cas_cci.c:2783</a></div></div>
<div class="ttc" id="classCCUBRIDDataSource_html_a6150ec7ab9bf9d29584095f1a9db6a77"><div class="ttname"><a href="classCCUBRIDDataSource.html#a6150ec7ab9bf9d29584095f1a9db6a77">CCUBRIDDataSource::CreateSession</a></div><div class="ttdeci">STDMETHOD() CreateSession(IUnknown *pUnkOuter, REFIID riid, IUnknown **ppDBSession)</div><div class="ttdef"><b>Definition:</b> <a href="DataSource_8cpp_source.html#l00161">DataSource.cpp:161</a></div></div>
<div class="ttc" id="classCCUBRIDDataSource_html_ae559e4101dfc33ee20a818d851242fd7"><div class="ttname"><a href="classCCUBRIDDataSource.html#ae559e4101dfc33ee20a818d851242fd7">CCUBRIDDataSource::Initialize</a></div><div class="ttdeci">STDMETHOD() Initialize(void)</div><div class="ttdef"><b>Definition:</b> <a href="DataSource_8cpp_source.html#l00052">DataSource.cpp:52</a></div></div>
<div class="ttc" id="classIDBInitializeImpl_html_ac3d11ba98f71e86cf15a8ee02708b50d"><div class="ttname"><a href="classIDBInitializeImpl.html#ac3d11ba98f71e86cf15a8ee02708b50d">IDBInitializeImpl::Uninitialize</a></div><div class="ttdeci">STDMETHOD() Uninitialize(void)</div><div class="ttdef"><b>Definition:</b> <a href="atldb__cubrid_8h_source.html#l02641">atldb_cubrid.h:2641</a></div></div>
<div class="ttc" id="classCUtlProps_html_acaa05098d3993e594f7c2e8c4e0b14e5"><div class="ttname"><a href="classCUtlProps.html#acaa05098d3993e594f7c2e8c4e0b14e5">CUtlProps&lt; CCUBRIDDataSource &gt;::GetPropValue</a></div><div class="ttdeci">OUT_OF_LINE HRESULT GetPropValue(const GUID *pguidPropSet, DBPROPID dwPropId, VARIANT *pvValue)</div><div class="ttdef"><b>Definition:</b> <a href="atldb__cubrid_8h_source.html#l11292">atldb_cubrid.h:11292</a></div></div>
<div class="ttc" id="namespaceUtil_html_a4f24c33d43a0f5439b654b1239599177"><div class="ttname"><a href="namespaceUtil.html#a4f24c33d43a0f5439b654b1239599177">Util::Disconnect</a></div><div class="ttdeci">HRESULT Disconnect(int *phConn)</div><div class="ttdef"><b>Definition:</b> <a href="util_8cpp_source.html#l00142">util.cpp:142</a></div></div>
<div class="ttc" id="classCCUBRIDDataSource_html"><div class="ttname"><a href="classCCUBRIDDataSource.html">CCUBRIDDataSource</a></div><div class="ttdef"><b>Definition:</b> <a href="DataSource_8h_source.html#l00091">DataSource.h:91</a></div></div>
<div class="ttc" id="classCCUBRIDDataSource_html_a1550f3bbf6d47c1f185e6075c998f3da"><div class="ttname"><a href="classCCUBRIDDataSource.html#a1550f3bbf6d47c1f185e6075c998f3da">CCUBRIDDataSource::GetKeywords</a></div><div class="ttdeci">STDMETHOD() GetKeywords(LPOLESTR *ppwszKeywords)</div><div class="ttdef"><b>Definition:</b> <a href="DataSource_8cpp_source.html#l00290">DataSource.cpp:290</a></div></div>
<div class="ttc" id="atldb__cubrid_8h_html_a4fccd5948653ba2d16fd2630803c94dda26437abf36c5c1502da84a9fac2aae89"><div class="ttname"><a href="atldb__cubrid_8h.html#a4fccd5948653ba2d16fd2630803c94dda26437abf36c5c1502da84a9fac2aae89">DSF_INITIALIZED</a></div><div class="ttdef"><b>Definition:</b> <a href="atldb__cubrid_8h_source.html#l01518">atldb_cubrid.h:1518</a></div></div>
<div class="ttc" id="mprec_8c_html_a91b64995742fd30063314f12340b4b5a"><div class="ttname"><a href="mprec_8c.html#a91b64995742fd30063314f12340b4b5a">b</a></div><div class="ttdeci">return b</div><div class="ttdef"><b>Definition:</b> <a href="mprec_8c_source.html#l00210">mprec.c:210</a></div></div>
<div class="ttc" id="Error_8h_html"><div class="ttname"><a href="Error_8h.html">Error.h</a></div></div>
<div class="ttc" id="mprec_8c_html_a66b97d6dee15f33d7b6731ccf48092cf"><div class="ttname"><a href="mprec_8c.html#a66b97d6dee15f33d7b6731ccf48092cf">c</a></div><div class="ttdeci">c</div><div class="ttdef"><b>Definition:</b> <a href="mprec_8c_source.html#l00368">mprec.c:368</a></div></div>
<div class="ttc" id="namespaceProvInfo_html_ac09fda6d1052a55d65a220f3649d405c"><div class="ttname"><a href="namespaceProvInfo.html#ac09fda6d1052a55d65a220f3649d405c">ProvInfo::size_LiteralInfos</a></div><div class="ttdeci">int size_LiteralInfos</div><div class="ttdef"><b>Definition:</b> <a href="ProviderInfo_8cpp_source.html#l00088">ProviderInfo.cpp:88</a></div></div>
<div class="ttc" id="classCCUBRIDDataSource_html_a5ed51ee59404677ed8ee6848124878af"><div class="ttname"><a href="classCCUBRIDDataSource.html#a5ed51ee59404677ed8ee6848124878af">CCUBRIDDataSource::GetDataSourcePtr</a></div><div class="ttdeci">static CCUBRIDDataSource * GetDataSourcePtr(IObjectWithSite *pSite)</div><div class="ttdef"><b>Definition:</b> <a href="DataSource_8cpp_source.html#l00042">DataSource.cpp:42</a></div></div>
<div class="ttc" id="classCUtlProps_html_a65763fbb6841a5b66fb0cd96b9a01fc9"><div class="ttname"><a href="classCUtlProps.html#a65763fbb6841a5b66fb0cd96b9a01fc9">CUtlProps&lt; CCUBRIDDataSource &gt;::SetPropValue</a></div><div class="ttdeci">HRESULT SetPropValue(const GUID *pguidPropSet, DBPROPID dwPropId, VARIANT *pvValue)</div><div class="ttdef"><b>Definition:</b> <a href="atldb__cubrid_8h_source.html#l11388">atldb_cubrid.h:11388</a></div></div>
<div class="ttc" id="namespaceProvInfo_html_a5332020d8ad7633a5ba86e21dcb11e99"><div class="ttname"><a href="namespaceProvInfo.html#a5332020d8ad7633a5ba86e21dcb11e99">ProvInfo::wszAllStrings</a></div><div class="ttdeci">WCHAR wszAllStrings[]</div><div class="ttdef"><b>Definition:</b> <a href="ProviderInfo_8cpp_source.html#l00037">ProviderInfo.cpp:37</a></div></div>
<div class="ttc" id="Error_8cpp_html_a93f7a306ed9bf1f41de89f2afea7f55d"><div class="ttname"><a href="Error_8cpp.html#a93f7a306ed9bf1f41de89f2afea7f55d">ClearError</a></div><div class="ttdeci">void ClearError()</div><div class="ttdef"><b>Definition:</b> <a href="Error_8cpp_source.html#l00058">Error.cpp:58</a></div></div>
<div class="ttc" id="classIDBCreateSessionImpl_html_a45da236fb4f240f09914a5dc86ba2683"><div class="ttname"><a href="classIDBCreateSessionImpl.html#a45da236fb4f240f09914a5dc86ba2683">IDBCreateSessionImpl::CreateSession</a></div><div class="ttdeci">STDMETHOD() CreateSession(IUnknown *pUnkOuter, REFIID riid, IUnknown **ppDBSession)</div><div class="ttdef"><b>Definition:</b> <a href="atldb__cubrid_8h_source.html#l02450">atldb_cubrid.h:2450</a></div></div>
<div class="ttc" id="atldb__cubrid_8h_html_a384404dfdbf1a0d41047dbe021b216d7"><div class="ttname"><a href="atldb__cubrid_8h.html#a384404dfdbf1a0d41047dbe021b216d7">E_OUTOFMEMORY</a></div><div class="ttdeci">else return E_OUTOFMEMORY</div><div class="ttdef"><b>Definition:</b> <a href="atldb__cubrid_8h_source.html#l02074">atldb_cubrid.h:2074</a></div></div>
<div class="ttc" id="freelistheap_8h_html_a070d2ce7b6bb7e5c05602aa8c308d0c4"><div class="ttname"><a href="freelistheap_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></div><div class="ttdeci">#define NULL</div><div class="ttdef"><b>Definition:</b> <a href="freelistheap_8h_source.html#l00019">freelistheap.h:19</a></div></div>
<div class="ttc" id="classIDBInitializeImpl_html_a16244ce38ecd287e65a5002e824cda6e"><div class="ttname"><a href="classIDBInitializeImpl.html#a16244ce38ecd287e65a5002e824cda6e">IDBInitializeImpl&lt; CCUBRIDDataSource &gt;::m_dwStatus</a></div><div class="ttdeci">DWORD m_dwStatus</div><div class="ttdef"><b>Definition:</b> <a href="atldb__cubrid_8h_source.html#l02686">atldb_cubrid.h:2686</a></div></div>
<div class="ttc" id="Error_8cpp_html_afda786ad5a25ec751d57b3b84d89dfec"><div class="ttname"><a href="Error_8cpp.html#afda786ad5a25ec751d57b3b84d89dfec">RaiseError</a></div><div class="ttdeci">HRESULT RaiseError(ERRORINFO &amp;info, CComVariant &amp;var, BSTR bstrSQLState)</div><div class="ttdef"><b>Definition:</b> <a href="Error_8cpp_source.html#l00063">Error.cpp:63</a></div></div>
<div class="ttc" id="ProviderInfo_8h_html"><div class="ttname"><a href="ProviderInfo_8h.html">ProviderInfo.h</a></div></div>
<div class="ttc" id="run-tests_8php_html_aaa193b0c1c2b93841472b26e2e281751"><div class="ttname"><a href="run-tests_8php.html#aaa193b0c1c2b93841472b26e2e281751">error</a></div><div class="ttdeci">error($message)</div><div class="ttdef"><b>Definition:</b> <a href="run-tests_8php_source.html#l02122">run-tests.php:2122</a></div></div>
<div class="ttc" id="classCCUBRIDDataSource_html_ac7add4a02fc27edc2b92f6a25d0a2429"><div class="ttname"><a href="classCCUBRIDDataSource.html#ac7add4a02fc27edc2b92f6a25d0a2429">CCUBRIDDataSource::DBPROPVAL_CS_UNINITIALIZED</a></div><div class="ttdeci">ATL_VARIANT_FALSE DBPROPVAL_CS_UNINITIALIZED</div><div class="ttdef"><b>Definition:</b> <a href="DataSource_8h_source.html#l00278">DataSource.h:278</a></div></div>
<div class="ttc" id="atldb__cubrid_8h_html_a1c8f62bc38a50376a62d4dad41a5e2aa"><div class="ttname"><a href="atldb__cubrid_8h.html#a1c8f62bc38a50376a62d4dad41a5e2aa">S_OK</a></div><div class="ttdeci">return S_OK</div><div class="ttdef"><b>Definition:</b> <a href="atldb__cubrid_8h_source.html#l02236">atldb_cubrid.h:2236</a></div></div>
<div class="ttc" id="mprec_8c_html_a4124bc0a9335c27f086f24ba207a4912"><div class="ttname"><a href="mprec_8c.html#a4124bc0a9335c27f086f24ba207a4912">a</a></div><div class="ttdeci">a</div><div class="ttdef"><b>Definition:</b> <a href="mprec_8c_source.html#l00189">mprec.c:189</a></div></div>
<div class="ttc" id="classCCUBRIDDataSource_html_af7e635787e2538b2259ea054254934c8"><div class="ttname"><a href="classCCUBRIDDataSource.html#af7e635787e2538b2259ea054254934c8">CCUBRIDDataSource::GetLiteralInfo</a></div><div class="ttdeci">STDMETHOD() GetLiteralInfo(ULONG cLiterals, const DBLITERAL rgLiterals[], ULONG *pcLiteralInfo, DBLITERALINFO **prgLiteralInfo, OLECHAR **ppCharBuffer)</div><div class="ttdef"><b>Definition:</b> <a href="DataSource_8cpp_source.html#l00198">DataSource.cpp:198</a></div></div>
<div class="ttc" id="cas__cci_8c_html_aa4fe754e67b8fb5f03d83d5b208d6be4"><div class="ttname"><a href="cas__cci_8c.html#aa4fe754e67b8fb5f03d83d5b208d6be4">cci_get_db_parameter</a></div><div class="ttdeci">int cci_get_db_parameter(int mapped_conn_id, T_CCI_DB_PARAM param_name, void *value, T_CCI_ERROR *err_buf)</div><div class="ttdef"><b>Definition:</b> <a href="cas__cci_8c_source.html#l01759">cas_cci.c:1759</a></div></div>
<div class="ttc" id="dynamic__load_8c_html_acb559820d9ca11295b4500f179ef6392"><div class="ttname"><a href="dynamic__load_8c.html#acb559820d9ca11295b4500f179ef6392">i</a></div><div class="ttdeci">int i</div><div class="ttdef"><b>Definition:</b> <a href="dynamic__load_8c_source.html#l00955">dynamic_load.c:955</a></div></div>
<div class="ttc" id="oledb_2stdafx_8h_html"><div class="ttname"><a href="oledb_2stdafx_8h.html">stdafx.h</a></div></div>
<div class="ttc" id="classCCUBRIDDataSource_html_aeb6fb1c9b1dafebed603ed51c86f26c1"><div class="ttname"><a href="classCCUBRIDDataSource.html#aeb6fb1c9b1dafebed603ed51c86f26c1">CCUBRIDDataSource::Uninitialize</a></div><div class="ttdeci">STDMETHOD() Uninitialize(void)</div><div class="ttdef"><b>Definition:</b> <a href="DataSource_8cpp_source.html#l00140">DataSource.cpp:140</a></div></div>
<div class="ttc" id="DataSource_8h_html"><div class="ttname"><a href="DataSource_8h.html">DataSource.h</a></div></div>
<div class="ttc" id="cas__cci_8h_html_a817a20323faf621d14b51bbaa4e4fcc8a7ef450f2374ea3427216e8d3ae4a333c"><div class="ttname"><a href="cas__cci_8h.html#a817a20323faf621d14b51bbaa4e4fcc8a7ef450f2374ea3427216e8d3ae4a333c">CCI_PARAM_MAX_STRING_LENGTH</a></div><div class="ttdef"><b>Definition:</b> <a href="cas__cci_8h_source.html#l00396">cas_cci.h:396</a></div></div>
<div class="ttc" id="structT__CCI__ERROR_html"><div class="ttname"><a href="structT__CCI__ERROR.html">T_CCI_ERROR</a></div><div class="ttdef"><b>Definition:</b> <a href="cas__cci_8h_source.html#l00271">cas_cci.h:271</a></div></div>
<div class="ttc" id="classCCUBRIDDataSource_html_aa5c311fe1d5a832eecab64cecf9e7b4d"><div class="ttname"><a href="classCCUBRIDDataSource.html#aa5c311fe1d5a832eecab64cecf9e7b4d">CCUBRIDDataSource::PARAM_MAX_STRING_LENGTH</a></div><div class="ttdeci">ULONG PARAM_MAX_STRING_LENGTH</div><div class="ttdef"><b>Definition:</b> <a href="DataSource_8h_source.html#l00107">DataSource.h:107</a></div></div>
<div class="ttc" id="classIDBInitializeImpl_html_a2402639b9a6fd4a8bb50a332933f817f"><div class="ttname"><a href="classIDBInitializeImpl.html#a2402639b9a6fd4a8bb50a332933f817f">IDBInitializeImpl&lt; CCUBRIDDataSource &gt;::m_cSessionsOpen</a></div><div class="ttdeci">LONG m_cSessionsOpen</div><div class="ttdef"><b>Definition:</b> <a href="atldb__cubrid_8h_source.html#l02693">atldb_cubrid.h:2693</a></div></div>
</div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_2c7dae788c48670d44a2add3356c436e.html">oledb</a></li><li class="navelem"><a class="el" href="DataSource_8cpp.html">DataSource.cpp</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
